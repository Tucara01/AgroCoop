<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compra Colectiva - Stellar dApp</title>
    <script src="https://unpkg.com/@stellar/stellar-sdk@12.1.0/dist/stellar-sdk.min.js"></script>
    <script type="module">
        // Importar Freighter API usando ES6 modules como indica la documentaci√≥n oficial
        import freighterApi from 'https://cdn.skypack.dev/@stellar/freighter-api';
        
        // Hacer disponible globalmente para compatibilidad
        window.freighterApi = freighterApi;
        window.freighter = freighterApi; // Alias para compatibilidad
        
        console.log('‚úÖ Freighter API importado correctamente:', freighterApi);
        
        // Disparar evento personalizado cuando est√© listo
        window.dispatchEvent(new CustomEvent('freighter-ready'));
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #666;
            font-size: 1.1em;
        }
        
        .wallet-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }

        .wallet-info {
            background: #e8f4f8;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
            border: 2px solid #bee5eb;
        }

        .wallet-info h4 {
            margin: 0 0 10px 0;
            color: #0c5460;
        }

        .wallet-info p {
            margin: 5px 0;
            color: #495057;
        }

        .wallet-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Estilos para el panel de direcci√≥n de wallet */
        .wallet-address-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .wallet-address-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .wallet-address-header h4 {
            margin: 0;
            color: white;
            font-size: 1.2em;
        }

        .connection-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .badge-dot {
            width: 8px;
            height: 8px;
            background: #4ade80;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .wallet-address-content {
            margin-bottom: 20px;
        }

        .address-section {
            margin-bottom: 15px;
        }

        .address-section label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.9);
        }

        .address-display {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.2);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .address-display code {
            flex: 1;
            background: none;
            color: #fbbf24;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            word-break: break-all;
            padding: 0;
        }

        .btn-copy {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .btn-copy:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .address-short {
            margin-top: 8px;
            text-align: center;
        }

        .address-short span {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
        }

        .network-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .network-section label {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
        }

        .network-badge {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: 600;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
            color: white;
        }

        .status-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .status-connected {
            background: #d4edda;
            color: #155724;
        }

        .status-disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .status-loading {
            background: #fff3cd;
            color: #856404;
        }

        /* Estilos para el panel de estado del proceso */
        .process-status-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .process-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .process-status-header h4 {
            margin: 0;
            color: white;
            font-size: 1.2em;
        }

        .process-status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .process-dot {
            width: 8px;
            height: 8px;
            background: #4ade80;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .process-status-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .process-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            opacity: 0.5;
        }

        .process-step.active {
            background: rgba(255, 255, 255, 0.2);
            opacity: 1;
            transform: scale(1.02);
        }

        .process-step.completed {
            background: rgba(34, 197, 94, 0.2);
            opacity: 1;
        }

        .step-icon {
            font-size: 1.2em;
            min-width: 24px;
        }

        .step-text {
            flex: 1;
            font-size: 0.9em;
        }

        .process-hash {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .process-hash label {
            display: block;
            font-size: 0.8em;
            margin-bottom: 5px;
            color: rgba(255, 255, 255, 0.8);
        }

        .process-hash code {
            background: rgba(0, 0, 0, 0.3);
            color: #fbbf24;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            word-break: break-all;
        }
        
        
        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        .btn:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-success {
            background: #28a745;
        }
        
        .btn-success:hover {
            background: #218838;
        }
        
        .btn-danger {
            background: #dc3545;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .pool-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .pool-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .pool-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .pool-id {
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .pool-status {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .status-active {
            background: #d4edda;
            color: #155724;
        }
        
        .status-funded {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status-expired {
            background: #f8d7da;
            color: #721c24;
        }
        
        .progress-bar {
            background: #e9ecef;
            border-radius: 10px;
            height: 20px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #28a745, #20c997);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .pool-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .info-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
        }
        
        .info-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .info-value {
            font-weight: bold;
            color: #333;
        }
        
        .connected {
            color: #28a745;
            font-weight: bold;
        }
        
        .disconnected {
            color: #dc3545;
            font-weight: bold;
        }
        
        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .alert-danger {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .pool-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõí Compra Colectiva</h1>
            <p>Plataforma descentralizada para compras grupales en Stellar</p>
        </div>

        <!-- Secci√≥n de Wallet -->
        <div class="wallet-section">
            <h3>üîó Conexi√≥n de Wallet</h3>
            <div id="wallet-status">
                <span id="status-indicator" class="status-indicator status-loading">üîÑ Verificando Freighter...</span>
                <br><br>
                <button class="btn" id="connect-btn" onclick="connectWallet()">Conectar Freighter</button>
                <button class="btn btn-danger" id="disconnect-btn" onclick="disconnectWallet()" style="display: none;">Desconectar</button>
                <button class="btn" id="retry-btn" onclick="retryFreighterDetection()" style="display: none;">üîÑ Reintentar Detecci√≥n</button>
            </div>
            
            <!-- Panel de Direcci√≥n de Wallet -->
            <div id="wallet-address-panel" class="wallet-address-panel" style="display: none;">
                <div class="wallet-address-header">
                    <h4>üîó Wallet Conectada</h4>
                    <div class="connection-badge" id="connection-badge">
                        <span class="badge-dot"></span>
                        <span id="connection-text">Conectado</span>
                    </div>
                </div>
                
                <div class="wallet-address-content">
                    <div class="address-section">
                        <label>Direcci√≥n de la Wallet:</label>
                        <div class="address-display">
                            <code id="full-address">No disponible</code>
                            <button class="btn-copy" id="copy-address-btn" onclick="copyAddress()" title="Copiar direcci√≥n">
                                üìã
                            </button>
                        </div>
                        <div class="address-short">
                            <span id="short-address">No disponible</span>
                        </div>
                    </div>
                    
                    <div class="network-section">
                        <label>Red:</label>
                        <span class="network-badge" id="network-badge">Testnet</span>
                    </div>
                </div>
                
                <div class="wallet-actions">
                    <button class="btn btn-secondary" onclick="getNetworkInfo()" id="network-btn">
                        üåê Info de Red
                    </button>
                    <button class="btn btn-secondary" onclick="signTestMessage()" id="sign-btn">
                        ‚úçÔ∏è Firmar Mensaje
                    </button>
                </div>
            </div>

            <!-- Panel de informaci√≥n b√°sica (oculto cuando hay wallet conectada) -->
            <div id="wallet-info" class="wallet-info" style="display: none;">
                <h4>üìã Informaci√≥n de la Wallet</h4>
                <p><strong>Direcci√≥n:</strong> <span id="user-address">No disponible</span></p>
                <p><strong>Red:</strong> <span id="network-name">No disponible</span></p>
                <p><strong>Estado:</strong> <span id="connection-status">Desconectado</span></p>
                
                <div class="wallet-actions">
                    <button class="btn" onclick="getNetworkInfo()" id="network-btn">Obtener Info de Red</button>
                    <button class="btn" onclick="signTestMessage()" id="sign-btn">Firmar Mensaje</button>
                </div>
            </div>
        </div>

        <!-- Alertas -->
        <div id="alerts"></div>

        <!-- Panel de Estado del Proceso -->
        <div id="process-status-panel" class="process-status-panel" style="display: none;">
            <div class="process-status-header">
                <h4>üîÑ Procesando Transacci√≥n</h4>
                <div class="process-status-badge" id="process-status-badge">
                    <span class="process-dot"></span>
                    <span id="process-status-text">Iniciando...</span>
                </div>
            </div>
            <div class="process-status-content">
                <div class="process-step" id="process-step-1">
                    <span class="step-icon">üìù</span>
                    <span class="step-text">Creando transacci√≥n...</span>
                </div>
                <div class="process-step" id="process-step-2">
                    <span class="step-icon">‚úçÔ∏è</span>
                    <span class="step-text">Firmando con Freighter...</span>
                </div>
                <div class="process-step" id="process-step-3">
                    <span class="step-icon">üì§</span>
                    <span class="step-text">Enviando a la red...</span>
                </div>
                <div class="process-step" id="process-step-4">
                    <span class="step-icon">‚è≥</span>
                    <span class="step-text">Esperando confirmaci√≥n...</span>
                </div>
                <div class="process-step" id="process-step-5">
                    <span class="step-icon">‚úÖ</span>
                    <span class="step-text">Procesando resultado...</span>
                </div>
            </div>
            <div class="process-hash" id="process-hash-display" style="display: none;">
                <label>Hash de la transacci√≥n:</label>
                <code id="process-hash-value">-</code>
            </div>
        </div>

        <!-- Grid principal -->
        <div class="grid">
            <!-- Crear Pool -->
            <div class="section">
                <h3>üìù Crear Pool</h3>
                <div class="form-group">
                    <label>Direcci√≥n del Proveedor:</label>
                    <input type="text" id="supplier" placeholder="GABC..." />
                </div>
                <div class="form-group">
                    <label>Meta (XLM):</label>
                    <input type="number" id="goal" placeholder="100" min="1" />
                </div>
                <div class="form-group">
                    <label>D√≠as hasta vencimiento:</label>
                    <input type="number" id="days" placeholder="30" min="1" />
                </div>
                <button class="btn btn-warning me-2" onclick="initializeContract()" id="init-btn" disabled>
                    üîß Inicializar Contrato
                </button>
                <button class="btn btn-success" onclick="createPool()" id="create-btn" disabled>
                    Crear Pool
                </button>
            </div>

            <!-- Contribuir -->
            <div class="section">
                <h3>üí∞ Contribuir</h3>
                <div class="form-group">
                    <label>ID del Pool:</label>
                    <input type="number" id="contrib-pool-id" placeholder="1" min="1" />
                </div>
                <div class="form-group">
                    <label>Cantidad (XLM):</label>
                    <input type="number" id="contrib-amount" placeholder="10" min="0.1" step="0.1" />
                </div>
                <button class="btn" onclick="contributeToPool()" id="contrib-btn" disabled>
                    Aprobar y Contribuir
                </button>
            </div>

            <!-- Acciones de Pool -->
            <div class="section">
                <h3>‚ö° Acciones</h3>
                <div class="form-group">
                    <label>ID del Pool:</label>
                    <input type="number" id="action-pool-id" placeholder="1" min="1" />
                </div>
                <button class="btn btn-success" onclick="finalizePool()" id="finalize-btn" disabled>
                    Finalizar Pool
                </button>
                <button class="btn btn-danger" onclick="requestRefund()" id="refund-btn" disabled>
                    Solicitar Reembolso
                </button>
                <button class="btn" onclick="getPoolInfo()" id="get-pool-btn" disabled>
                    Ver Estado
                </button>
            </div>
        </div>

        <!-- Lista de Pools -->
        <div class="section">
            <h3>üìä Pools Activos</h3>
            <button class="btn" onclick="loadActivePools()" id="load-pools-btn" disabled>
                Cargar Pools
            </button>
            <div id="pools-list"></div>
        </div>
    </div>

    <script>
        // Configuraci√≥n
        const CONFIG = {
            contractId: 'CBAID77FC57C6LNDGPS2RTTWA6RZY72LXJYQMLZMX3NBO4VSWGXLTVT2',
            // XLM nativo en Soroban testnet - direcci√≥n correcta del contrato de token XLM
            tokenId: 'CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC',
            network: 'testnet',
            rpcUrl: 'https://soroban-testnet.stellar.org',
            sorobanRpcUrl: 'https://soroban-testnet.stellar.org', // URL espec√≠fica para RPC crudo
            // Passphrase correcta para testnet
            networkPassphrase: 'Test SDF Network ; September 2015'
        };

        // Variables globales
        let server;
        let userAddress = null;
        let isConnected = false;
        let isFreighterAvailable = false;

        // Elementos DOM
        const statusIndicator = () => document.getElementById('status-indicator');
        const connectBtn = () => document.getElementById('connect-btn');
        const disconnectBtn = () => document.getElementById('disconnect-btn');
        const walletInfo = () => document.getElementById('wallet-info');
        const walletAddressPanel = () => document.getElementById('wallet-address-panel');
        const userAddressSpan = () => document.getElementById('user-address');
        const networkNameSpan = () => document.getElementById('network-name');
        const connectionStatusSpan = () => document.getElementById('connection-status');
        
        // Referencias para el nuevo panel de direcci√≥n
        const fullAddressSpan = () => document.getElementById('full-address');
        const shortAddressSpan = () => document.getElementById('short-address');
        const networkBadgeSpan = () => document.getElementById('network-badge');
        const connectionTextSpan = () => document.getElementById('connection-text');

        // Inicializar aplicaci√≥n
        async function init() {
            console.log('üöÄ Inicializando dApp...');
            server = new StellarSdk.SorobanRpc.Server(CONFIG.rpcUrl);
            
            // Cargar hash de transacci√≥n desde localStorage
            loadLastTransaction();
            
            // Esperar a que se carguen los scripts y verificar disponibilidad
            let retries = 0;
            const maxRetries = 10;
            
            while (retries < maxRetries) {
                if (typeof StellarSdk !== 'undefined') {
                    console.log('‚úÖ Stellar SDK cargado');
                    break;
                }
                await new Promise(resolve => setTimeout(resolve, 500));
                retries++;
            }
            
            if (retries >= maxRetries) {
                showAlert('‚ùå Error: No se pudo cargar Stellar SDK', 'danger');
                return;
            }
            
            // Mostrar estado inicial mientras verificamos Freighter
            statusIndicator().textContent = 'üîÑ Verificando Freighter...';
            statusIndicator().className = 'status-indicator status-loading';
            
            // Verificar Freighter (esto incluye su propio updateUI al final)
            await checkFreighterAvailability();
        }

        // Verificar disponibilidad de Freighter usando la API oficial importada
        async function checkFreighterAvailability() {
            console.log('üîç Verificando Freighter usando API oficial importada...');
            
            // Esperar a que el m√≥dulo ES6 se cargue
            const waitForFreighterAPI = () => {
                return new Promise((resolve) => {
                    // Si ya est√° disponible
                    if (window.freighterApi) {
                        console.log('‚úÖ Freighter API ya disponible');
                        resolve(true);
                        return;
                    }
                    
                    // Escuchar evento de carga del m√≥dulo
                    const handleFreighterReady = () => {
                        console.log('‚úÖ Freighter API cargado desde m√≥dulo ES6');
                        window.removeEventListener('freighter-ready', handleFreighterReady);
                        resolve(true);
                    };
                    
                    window.addEventListener('freighter-ready', handleFreighterReady);
                    
                    // Timeout despu√©s de 5 segundos
                    setTimeout(() => {
                        window.removeEventListener('freighter-ready', handleFreighterReady);
                        console.log('‚ùå Timeout esperando Freighter API');
                        resolve(false);
                    }, 5000);
                });
            };
            
            const apiLoaded = await waitForFreighterAPI();
            
            if (apiLoaded && window.freighterApi) {
                console.log('‚úÖ Freighter API detectado correctamente');
                
                // Normalizar API
                window.freighter = window.freighterApi;
                
                await handleFreighterDetected();
                return;
            }
            
            // Si no se carg√≥ la API, mostrar error espec√≠fico
            console.log('‚ùå Freighter API no se pudo cargar');
            console.log('üí° Posibles causas:');
            console.log('   - Problema de red (CDN no disponible)');
            console.log('   - Navegador no soporta ES6 modules');
            console.log('   - Bloqueador de contenido bloqueando el CDN');
            console.log('   - Extensi√≥n Freighter no instalada');
            
            handleFreighterNotFound();
        }

        // Manejar Freighter detectado
        async function handleFreighterDetected() {
            try {
                isFreighterAvailable = true;
                console.log('üéâ Freighter confirmado como disponible');
                
                // Verificar m√©todos disponibles
                
                // Verificar si hay una conexi√≥n existente
                let isConnectedResult = false;
                try {
                    isConnectedResult = await window.freighter.isConnected();
                } catch (e) {
                    console.log('‚ö†Ô∏è No se pudo verificar estado de conexi√≥n:', e.message);
                }
                
                if (isConnectedResult) {
                    try {
                        // Intentar obtener la clave p√∫blica de diferentes maneras
                        let publicKey = null;
                        
                        try {
                            // Intentar getAddress() primero (m√°s ligero)
                            const addressResult = await window.freighter.getAddress();
                            
                            if (addressResult && !addressResult.error && addressResult.address) {
                                userAddress = addressResult.address;
                                isConnected = true;
                                showAlert('‚úÖ Freighter conectado autom√°ticamente', 'success');
                                await updateNetworkInfo();
                            } else {
                                // Si getAddress() no funciona, intentar requestAccess()
                                const accessResult = await window.freighter.requestAccess();
                                
                                if (accessResult && !accessResult.error && accessResult.address) {
                                    userAddress = accessResult.address;
                                    isConnected = true;
                                    showAlert('‚úÖ Freighter conectado autom√°ticamente', 'success');
                                    await updateNetworkInfo();
                                } else {
                                    showAlert('üí° Freighter detectado. Haz clic en "Conectar" para continuar.', 'info');
                                }
                            }
                        } catch (e) {
                            console.log('‚ö†Ô∏è Error obteniendo direcci√≥n:', e.message);
                            showAlert('üí° Freighter detectado. Haz clic en "Conectar" para continuar.', 'info');
                        }
                    } catch (pkError) {
                        console.log('‚ö†Ô∏è No hay clave p√∫blica disponible, requiere conexi√≥n manual:', pkError.message);
                        showAlert('üí° Freighter detectado. Haz clic en "Conectar" para continuar.', 'info');
                    }
                } else {
                    showAlert('üí° Freighter detectado. Haz clic en "Conectar" para continuar.', 'info');
                }
            } catch (error) {
                console.error('Error manejando Freighter detectado:', error);
                showAlert('‚ö†Ô∏è Freighter detectado pero con errores: ' + error.message, 'danger');
                // A√∫n as√≠, marcar como disponible para permitir intentos de conexi√≥n
                isFreighterAvailable = true;
            } finally {
                updateUI();
            }
        }

        // Manejar Freighter no encontrado
        function handleFreighterNotFound() {
            isFreighterAvailable = false;
            
            // Mostrar mensaje espec√≠fico para el problema de inyecci√≥n
            const isChrome = navigator.userAgent.includes('Chrome');
            let message = '‚ùå Freighter no se est√° inyectando correctamente.';
            
            if (isChrome) {
                message += '\n\nüîß Soluciones para Chrome:';
                message += '\n1. Verifica que Freighter est√© habilitado en chrome://extensions/';
                message += '\n2. Aseg√∫rate de que "Permitir en modo inc√≥gnito" est√© activado si usas inc√≥gnito';
                message += '\n3. Recarga la extensi√≥n (toggle off/on)';
                message += '\n4. Reinicia Chrome completamente';
                message += '\n5. Si el problema persiste, reinstala Freighter';
            }
            
            showAlert(message, 'danger');
            
            // Mostrar botones de acci√≥n
            document.getElementById('retry-btn').style.display = 'inline-block';
            
            const connectButton = connectBtn();
            connectButton.textContent = isChrome ? 'Abrir Extensiones Chrome' : 'Instalar Freighter';
            connectButton.disabled = false;
            connectButton.onclick = () => {
                if (isChrome) {
                    // Abrir p√°gina de extensiones de Chrome
                    window.open('chrome://extensions/', '_blank');
                    showAlert('‚ÑπÔ∏è Verifica que Freighter est√© habilitado, luego usa "Reintentar Detecci√≥n".', 'info');
                } else {
                    window.open('https://freighter.app/', '_blank');
                    showAlert('‚ÑπÔ∏è Despu√©s de instalar Freighter, usa "Reintentar Detecci√≥n".', 'info');
                }
            };
            
            updateUI();
        }

        // Funci√≥n para reintentar la detecci√≥n de Freighter
        async function retryFreighterDetection() {
            showAlert('üîÑ Reintentando detecci√≥n de Freighter...', 'info');
            
            // Resetear estado
            document.getElementById('retry-btn').style.display = 'none';
            statusIndicator().textContent = 'üîÑ Verificando Freighter...';
            statusIndicator().className = 'status-indicator status-loading';
            
            // Reintentar detecci√≥n
            await checkFreighterAvailability();
        }

        // Conectar wallet usando la API oficial correcta
        async function connectWallet() {
            if (!isFreighterAvailable) {
                showAlert('‚ùå Freighter no est√° disponible', 'danger');
                return;
            }

            try {
                statusIndicator().textContent = 'üîÑ Conectando...';
                statusIndicator().className = 'status-indicator status-loading';
                connectBtn().disabled = true;

                console.log('üîÑ Conectando con Freighter usando API oficial...');
                
                // Usar requestAccess() seg√∫n la documentaci√≥n oficial
                // requestAccess() -> Promise<{ address: string } & { error?: string }>
                console.log('üîë Llamando a requestAccess()...');
                const accessResult = await window.freighter.requestAccess();
                console.log('üîë requestAccess() resultado:', accessResult);
                
                // Verificar si hay error
                if (accessResult.error) {
                    throw new Error(accessResult.error);
                }
                
                // Obtener la direcci√≥n del resultado
                if (!accessResult.address || typeof accessResult.address !== 'string') {
                    throw new Error('No se recibi√≥ una direcci√≥n v√°lida de Freighter');
                }
                
                // Guardar la direcci√≥n
                userAddress = accessResult.address;
                isConnected = true;
                
                console.log('‚úÖ Wallet conectada exitosamente');
                console.log('üìç Direcci√≥n:', userAddress);
                
                // Actualizar informaci√≥n de red
                await updateNetworkInfo();
                
                // Mostrar √©xito
                showAlert('‚úÖ Wallet conectada exitosamente', 'success');
                
            } catch (error) {
                console.error('‚ùå Error conectando wallet:', error);
                showAlert('‚ùå Error al conectar: ' + error.message, 'danger');
                isConnected = false;
                userAddress = null;
            } finally {
                connectBtn().disabled = false;
                updateUI();
            }
        }

        // Desconectar wallet
        function disconnectWallet() {
            isConnected = false;
            userAddress = null;
            showAlert('‚ÑπÔ∏è Wallet desconectada', 'info');
            updateUI();
        }

        // Actualizar informaci√≥n de red usando la API oficial
        async function updateNetworkInfo() {
            if (!isConnected || !userAddress) return;
            
            try {
                console.log('üåê Obteniendo informaci√≥n de red...');
                
                // Usar getNetworkDetails() seg√∫n la documentaci√≥n oficial
                // getNetworkDetails() -> Promise<{ network: string; networkUrl: string; networkPassphrase: string; sorobanRpcUrl?: string; } & { error?: string; }>
                const networkDetails = await window.freighter.getNetworkDetails();
                console.log('üåê getNetworkDetails() resultado:', networkDetails);
                
                if (networkDetails.error) {
                    throw new Error(networkDetails.error);
                }
                
                // Actualizar la UI con la informaci√≥n obtenida
                const networkName = networkDetails.network || 'Testnet (por defecto)';
                document.getElementById('network-name').textContent = networkName;
                networkBadgeSpan().textContent = networkName;
                
                // Los elementos passphrase y sorobanRpc no existen en la UI actual, solo los logueamos
                console.log('üìù Passphrase:', networkDetails.networkPassphrase);
                console.log('üîó Soroban RPC:', networkDetails.sorobanRpcUrl);
                
                console.log('‚úÖ Informaci√≥n de red actualizada correctamente');
                
            } catch (error) {
                console.error('‚ùå Error obteniendo informaci√≥n de red:', error);
                
                // Usar valores por defecto en caso de error
                const defaultNetwork = 'Testnet (por defecto)';
                document.getElementById('network-name').textContent = defaultNetwork;
                networkBadgeSpan().textContent = defaultNetwork;
                
                console.log('‚ö†Ô∏è Usando valores por defecto para la red');
            }
        }

        // Obtener informaci√≥n detallada de la red
        async function getNetworkInfo() {
            if (!isConnected) {
                showAlert('‚ùå Conecta la wallet primero', 'danger');
                return;
            }

            try {
                console.log('üåê Obteniendo informaci√≥n detallada de la red...');
                
                // Usar getNetworkDetails() seg√∫n la documentaci√≥n oficial
                const networkDetails = await window.freighter.getNetworkDetails();
                console.log('üåê getNetworkDetails() resultado:', networkDetails);
                
                if (networkDetails.error) {
                    throw new Error(networkDetails.error);
                }

                const info = `
                    Red: ${networkDetails.network}
                    URL: ${networkDetails.networkUrl}
                    Passphrase: ${networkDetails.networkPassphrase}
                    ${networkDetails.sorobanRpcUrl ? 'Soroban RPC: ' + networkDetails.sorobanRpcUrl : ''}
                `;
                
                console.log('‚úÖ Informaci√≥n de red obtenida:', info);
                showAlert('üì° Informaci√≥n de red:\n' + info, 'info');
                
            } catch (error) {
                console.error('‚ùå Error obteniendo informaci√≥n de red:', error);
                
                // Usar valores por defecto en caso de error
                let info = `Red: Testnet (por defecto)\n`;
                info += `Passphrase: ${CONFIG.networkPassphrase}\n`;
                info += `Soroban RPC: ${CONFIG.rpcUrl}`;
                showAlert('üì° Informaci√≥n de red:\n' + info, 'info');
            }
        }

        // Firmar mensaje de prueba usando la API oficial
        async function signTestMessage() {
            if (!isConnected || !userAddress) {
                showAlert('‚ùå Conecta la wallet primero', 'danger');
                return;
            }

            try {
                console.log('‚úçÔ∏è Iniciando prueba de firma...');
                
                const message = 'Compra Colectiva - Mensaje de prueba desde la dApp';
                console.log('üìù Mensaje a firmar:', message);
                
                // Usar signMessage() seg√∫n la documentaci√≥n oficial
                // signMessage(message: string, opts: { address: string }) -> Promise<{ signedMessage: string | null; signerAddress: string; } & { error?: string; }>
                const signResult = await window.freighter.signMessage(message, {
                    address: userAddress
                });
                
                console.log('‚úçÔ∏è signMessage() resultado:', signResult);
                
                if (signResult.error) {
                    throw new Error(signResult.error);
                }
                
                if (!signResult.signedMessage) {
                    throw new Error('No se recibi√≥ un mensaje firmado');
                }

                console.log('‚úÖ Mensaje firmado exitosamente');
                console.log('üîê Mensaje firmado:', signResult.signedMessage);
                console.log('üë§ Firmado por:', signResult.signerAddress);
                
                showAlert('‚úÖ Mensaje firmado correctamente', 'success');
                
            } catch (error) {
                console.error('‚ùå Error firmando mensaje:', error);
                showAlert('‚ùå Error firmando: ' + error.message, 'danger');
            }
        }

        // Funci√≥n para copiar la direcci√≥n al portapapeles
        async function copyAddress() {
            if (!userAddress) {
                showAlert('‚ùå No hay direcci√≥n para copiar', 'danger');
                return;
            }

            try {
                await navigator.clipboard.writeText(userAddress);
                showAlert('‚úÖ Direcci√≥n copiada al portapapeles', 'success');
                
                // Cambiar temporalmente el √≠cono del bot√≥n
                const copyBtn = document.getElementById('copy-address-btn');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '‚úÖ';
                copyBtn.style.background = 'rgba(34, 197, 94, 0.3)';
                
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                }, 2000);
                
            } catch (error) {
                console.error('Error copiando direcci√≥n:', error);
                showAlert('‚ùå Error al copiar la direcci√≥n', 'danger');
            }
        }

        // Actualizar interfaz de usuario
        function updateUI() {
            const indicator = statusIndicator();
            const connectButton = connectBtn();
            const disconnectButton = disconnectBtn();
            const walletInfoDiv = walletInfo();
            const walletAddressPanelDiv = walletAddressPanel();
            const userAddrSpan = userAddressSpan();
            const connStatusSpan = connectionStatusSpan();

            if (isConnected && userAddress) {
                // Estado conectado - mostrar panel de direcci√≥n
                indicator.textContent = '‚úÖ Conectado';
                indicator.className = 'status-indicator status-connected';
                
                connectButton.style.display = 'none';
                disconnectButton.style.display = 'inline-block';
                
                // Mostrar panel de direcci√≥n y ocultar panel b√°sico
                walletAddressPanelDiv.style.display = 'block';
                walletInfoDiv.style.display = 'none';
                
                // Actualizar panel de direcci√≥n
                if (userAddress && typeof userAddress === 'string') {
                    fullAddressSpan().textContent = userAddress;
                    shortAddressSpan().textContent = `${userAddress.slice(0, 8)}...${userAddress.slice(-8)}`;
                } else {
                    fullAddressSpan().textContent = 'No disponible';
                    shortAddressSpan().textContent = 'No disponible';
                }
                connectionTextSpan().textContent = 'Conectado';
                
                // Actualizar panel b√°sico (por compatibilidad)
                userAddrSpan.textContent = (userAddress && typeof userAddress === 'string') ? `${userAddress.slice(0, 8)}...${userAddress.slice(-8)}` : 'No disponible';
                connStatusSpan.textContent = 'Conectado';
                
                enableActionButtons();
                
            } else if (isFreighterAvailable) {
                // Freighter disponible pero no conectado
                indicator.textContent = '‚ùå Desconectado';
                indicator.className = 'status-indicator status-disconnected';
                
                connectButton.style.display = 'inline-block';
                connectButton.disabled = false;
                disconnectButton.style.display = 'none';
                
                // Ocultar ambos paneles
                walletAddressPanelDiv.style.display = 'none';
                walletInfoDiv.style.display = 'none';
                userAddrSpan.textContent = 'No disponible';
                connStatusSpan.textContent = 'Desconectado';
                
                disableActionButtons();
                
            } else {
                // Freighter no disponible
                indicator.textContent = '‚ùå Freighter no disponible';
                indicator.className = 'status-indicator status-disconnected';
                
                connectButton.style.display = 'inline-block';
                connectButton.disabled = true;
                connectButton.textContent = 'Instalar Freighter';
                disconnectButton.style.display = 'none';
                
                // Ocultar ambos paneles
                walletAddressPanelDiv.style.display = 'none';
                walletInfoDiv.style.display = 'none';
                userAddrSpan.textContent = 'No disponible';
                connStatusSpan.textContent = 'No disponible';
                
                disableActionButtons();
            }
        }

        // Habilitar botones de acci√≥n
        function enableActionButtons() {
            const buttons = ['init-btn', 'create-btn', 'contrib-btn', 'finalize-btn', 'refund-btn', 'get-pool-btn', 'load-pools-btn'];
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = false;
            });
        }

        // Deshabilitar botones de acci√≥n
        function disableActionButtons() {
            const buttons = ['init-btn', 'create-btn', 'contrib-btn', 'finalize-btn', 'refund-btn', 'get-pool-btn', 'load-pools-btn'];
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = true;
            });
        }

        // Funci√≥n para enviar logs al servidor
        async function sendLogToServer(level, message, data = null, operation = null) {
            try {
                await fetch('/api/log', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        level,
                        message,
                        data,
                        operation
                    })
                });
            } catch (error) {
                console.warn('No se pudo enviar log al servidor:', error);
            }
        }

        // Funci√≥n para enviar logs de transacciones al servidor
        async function sendTransactionLog(operation, details, status, error = null) {
            try {
                await fetch('/api/log-transaction', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        operation,
                        details,
                        status,
                        error
                    })
                });
            } catch (err) {
                console.warn('No se pudo enviar log de transacci√≥n:', err);
            }
        }

        // Funci√≥n para enviar logs de errores al servidor
        async function sendErrorLog(error, context, stack = null) {
            try {
                await fetch('/api/log-error', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        error: error.message || error,
                        context,
                        stack
                    })
                });
            } catch (err) {
                console.warn('No se pudo enviar log de error:', err);
            }
        }

        // Mostrar alertas
        function showAlert(message, type = 'info') {
            const alertsDiv = document.getElementById('alerts');
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.style.whiteSpace = 'pre-line'; // Para mostrar saltos de l√≠nea
            alertDiv.textContent = message;
            alertsDiv.appendChild(alertDiv);
            
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.parentNode.removeChild(alertDiv);
                }
            }, 8000);
        }

        // === FUNCIONES DE POOL (STUBS) ===


        // Verificar conectividad con el contrato
        async function verifyContractConnection() {
            try {
                console.log('üîç Verificando conectividad con el contrato...');
                const account = await server.getAccount(userAddress);
                
                // Intentar una consulta simple al contrato usando get_pool
                const testTransaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(
                    StellarSdk.Operation.invokeContractFunction({
                        contract: CONFIG.contractId,
                        function: 'get_pool', // Funci√≥n que existe
                        args: [StellarSdk.nativeToScVal(1, { type: 'u32' })]
                    })
                )
                .setTimeout(30)
                .build();

                // Solo simular la transacci√≥n, no enviarla
                const simulation = await server.simulateTransaction(testTransaction);
                console.log('‚úÖ Contrato accesible:', simulation);
                return simulation; // Return the full simulation result
            } catch (error) {
                console.warn('‚ö†Ô∏è No se pudo verificar el contrato:', error.message);
                return { error: error.message }; // Return error object
            }
        }

        // Verificar si el contrato est√° inicializado
        async function isContractInitialized() {
            try {
                console.log('üîç Verificando si el contrato est√° inicializado...');
                const account = await server.getAccount(userAddress);
                
                // Intentar simular una operaci√≥n que requiere inicializaci√≥n
                // Usamos get_pool con ID 1 (que deber√≠a fallar si no est√° inicializado)
                const testTransaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(
                    StellarSdk.Operation.invokeContractFunction({
                        contract: CONFIG.contractId,
                        function: 'get_pool',
                        args: [StellarSdk.nativeToScVal(1, { type: 'u32' })]
                    })
                )
                .setTimeout(30)
                .build();

                const simulation = await server.simulateTransaction(testTransaction);
                
                // Si hay error con MissingValue, el contrato no est√° inicializado
                if (simulation.error && simulation.error.includes('MissingValue')) {
                    console.log('‚ùå Contrato NO inicializado (MissingValue detectado)');
                    return false;
                }
                
                // Si no hay error MissingValue, asumimos que est√° inicializado
                console.log('‚úÖ Contrato inicializado correctamente');
                return true;
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Error verificando inicializaci√≥n:', error.message);
                return false;
            }
        }

        // Inicializar el contrato si es necesario
        async function initializeContract() {
            if (!isConnected || !userAddress) {
                showAlert('‚ùå Conecta la wallet para inicializar el contrato', 'danger');
                return;
            }

            try {
                console.log('üîß Verificando estado del contrato...');
                
                // Verificar si ya est√° inicializado llamando a get_pool_count
                const contractCheck = await verifyContractConnection();
                
                // Check if contractCheck has error with MissingValue
                let needsInitialization = false;
                if (contractCheck.error && contractCheck.error.includes('MissingValue')) {
                    needsInitialization = true;
                    console.log('üîß Contrato no inicializado (MissingValue detectado)');
                } else if (contractCheck.error) {
                    console.log('‚ö†Ô∏è Error en verificaci√≥n, pero no MissingValue:', contractCheck.error);
                    // Assume it might be initialized or other error
                    showAlert('‚ö†Ô∏è No se puede determinar el estado del contrato', 'warning');
                    return;
                } else {
                    console.log('‚úÖ El contrato ya est√° inicializado (get_pool_count simulado exitosamente)');
                    showAlert('‚úÖ El contrato ya est√° inicializado', 'info');
                    return;
                }
                
                if (!needsInitialization) {
                    return;
                }
                
                console.log('üîß Inicializando contrato...');
                
                let account;
                try {
                    account = await server.getAccount(userAddress);
                } catch (accountError) {
                    console.error('‚ùå Error obteniendo cuenta:', accountError);
                    throw new Error('No se pudo obtener informaci√≥n de la cuenta.');
                }
                
                // 1) Construir operaci√≥n
                const operation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'initialize',
                    args: []
                });

                // 2) Armar transacci√≥n base
                let transaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(operation)
                .setTimeout(600) // 10 minutos para dar tiempo a Freighter
                .build();

                // 3) Simular y preparar
                console.log('üîç Simulando transacci√≥n de inicializaci√≥n...');
                const simulation = await server.simulateTransaction(transaction);
                console.log('üìä Simulaci√≥n:', simulation);
                
                if (simulation.error) {
                    throw new Error('Error en simulaci√≥n: ' + simulation.error);
                }

                console.log('üîß Preparando transacci√≥n...');
                transaction = await server.prepareTransaction(transaction);
                console.log('‚úÖ Transacci√≥n preparada con footprint y autorizaci√≥n');

                console.log('‚úçÔ∏è Firmando transacci√≥n de inicializaci√≥n...');
                
                const signedTransaction = await window.freighter.signTransaction(transaction.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress  // unifica: usa 'address' para ser consistente
                });

                if (signedTransaction.error) {
                    console.error('‚ùå Error de Freighter:', signedTransaction.error);
                    throw new Error('Error firmando transacci√≥n: ' + signedTransaction.error);
                }

                console.log('üì§ Enviando transacci√≥n de inicializaci√≥n...');
                
                // 4) Enviar - usar fallback para ambas variantes de Freighter
                const signedXdr = signedTransaction.signedTxXdr ?? signedTransaction.signedXDR;
                if (!signedXdr) {
                    throw new Error('Freighter no retorn√≥ XDR firmada (signedTxXdr/signedXDR)');
                }
                
                const transactionToSubmit = StellarSdk.TransactionBuilder.fromXDR(
                    signedXdr,
                    CONFIG.networkPassphrase
                );

                const response = await server.sendTransaction(transactionToSubmit);
                console.log('üìä Respuesta completa:', response);
                console.log('üìä Status:', response.status);

                if (response.status === 'SUCCESS') {
                    showAlert('‚úÖ Contrato inicializado exitosamente!', 'success');
                } else {
                    console.log('‚ùå Error details:', JSON.stringify(response.errorResult));
                    if (response.errorResult && response.errorResult.result && response.errorResult.result._switch && response.errorResult.result._switch.name === 'txFailed') {
                        // Check for specific panic message "Already initialized"
                        const diagnosticEvents = response.errorResult.result.diagnosticEvents || [];
                        const alreadyInitialized = diagnosticEvents.some(event => event.message && event.message.includes('Already initialized'));
                        if (alreadyInitialized) {
                            showAlert('‚úÖ El contrato ya est√° inicializado', 'info');
                        } else {
                            showAlert('‚ö†Ô∏è Error interno en el contrato', 'warning');
                        }
                    } else {
                        throw new Error('La transacci√≥n fall√≥: ' + response.status + ' - ' + JSON.stringify(response.errorResult));
                    }
                }

            } catch (error) {
                console.error('‚ùå Error inicializando contrato:', error.message);
                showAlert('‚ùå Error inicializando contrato: ' + error.message, 'danger');
            }
        }

        // Crear un nuevo pool de compra colectiva
        async function createPool() {
            if (!isConnected || !userAddress) {
                showAlert('‚ùå Conecta la wallet para crear un pool', 'danger');
                return;
            }

            try {
                // Verificar si el contrato est√° inicializado
                showAlert('üîç Verificando estado del contrato...', 'info');
                const isInitialized = await isContractInitialized();
                
                if (!isInitialized) {
                    showAlert('‚ùå El contrato no est√° inicializado. Haz clic en "Inicializar Contrato" primero.', 'danger');
                    return;
                }

                // Obtener datos del formulario
                const supplierAddress = document.getElementById('supplier').value.trim();
                const goalXlm = parseInt(document.getElementById('goal').value);
                const daysUntilExpiry = parseInt(document.getElementById('days').value);

                // Debug: Log de la direcci√≥n obtenida
                // Validaci√≥n b√°sica del proveedor

                // Validaciones
                if (!supplierAddress) {
                    showAlert('‚ùå Ingresa la direcci√≥n del proveedor', 'danger');
                    return;
                }

                if (!goalXlm || goalXlm <= 0) {
                    showAlert('‚ùå La meta debe ser mayor a 0 XLM', 'danger');
                    return;
                }

                if (!daysUntilExpiry || daysUntilExpiry <= 0) {
                    showAlert('‚ùå Los d√≠as hasta vencimiento deben ser mayor a 0', 'danger');
                    return;
                }

                // Convertir XLM a stroops (1 XLM = 10,000,000 stroops)
                const goalStroops = BigInt(goalXlm * 10000000);
                
                // Calcular deadline (timestamp actual + d√≠as en segundos)
                const now = Math.floor(Date.now() / 1000);
                const deadline = now + (daysUntilExpiry * 24 * 60 * 60);
                
                // Validar longitud de la direcci√≥n (debe ser exactamente 56 caracteres)
                if (supplierAddress.length !== 56) {
                    showAlert(`‚ùå La direcci√≥n debe tener exactamente 56 caracteres. Tienes: ${supplierAddress.length}`, 'danger');
                    return;
                }

                // Validar formato de la direcci√≥n
                if (!supplierAddress.startsWith('G')) {
                    showAlert('‚ùå La direcci√≥n debe empezar con "G"', 'danger');
                    return;
                }

                // Validar que sea una direcci√≥n Stellar v√°lida
                if (!StellarSdk.StrKey.isValidEd25519PublicKey(supplierAddress)) {
                    showAlert('‚ùå La direcci√≥n del proveedor no es v√°lida. Debe ser una direcci√≥n Stellar v√°lida', 'danger');
                    return;
                }
                
                // Verificar que la direcci√≥n sea diferente a la del usuario
                if (supplierAddress === userAddress) {
                    showAlert('‚ùå No puedes ser tu propio proveedor', 'danger');
                    return;
                }

                console.log('üèóÔ∏è Creando pool...');
                console.log('üìç Proveedor:', supplierAddress);
                console.log('üéØ Meta:', goalXlm, 'XLM');
                console.log('‚è∞ Deadline:', new Date(deadline * 1000).toLocaleString());

                // Mostrar panel de proceso
                showProcessPanel();
                setProcessStep(1);
                updateProcessStatus('Creando transacci√≥n...');

                // Enviar log al servidor
                await sendLogToServer('info', 'Iniciando creaci√≥n de pool', {
                    supplier: supplierAddress,
                    goal: goalXlm,
                    deadline: new Date(deadline * 1000).toISOString(),
                    contractId: CONFIG.contractId,
                    tokenId: CONFIG.tokenId
                }, 'CREATE_POOL');

                // Crear transacci√≥n para invocar el contrato
                let account;
                try {
                    account = await server.getAccount(userAddress);
                } catch (accountError) {
                    console.error('‚ùå Error obteniendo cuenta:', accountError);
                    throw new Error('No se pudo obtener informaci√≥n de la cuenta. Verifica que la wallet tenga fondos suficientes.');
                }
                
                // Crear addresses necesarios
                let creatorAddress = StellarSdk.Address.fromString(userAddress);
                
                let tokenAddress = StellarSdk.Address.fromString(CONFIG.tokenId);
                let supplierAddressObj = StellarSdk.Address.fromString(supplierAddress);
                
                const goalScVal = StellarSdk.nativeToScVal(goalStroops, { type: 'i128' });
                const deadlineScVal = StellarSdk.nativeToScVal(deadline, { type: 'u64' });
                
                // Convertir addresses a ScVal
                const creatorScVal = StellarSdk.nativeToScVal(creatorAddress, { type: 'address' });
                const tokenScVal = StellarSdk.nativeToScVal(tokenAddress, { type: 'address' });
                const supplierScVal = StellarSdk.nativeToScVal(supplierAddressObj, { type: 'address' });
                
                console.log('üìù Argumentos preparados:');
                console.log('  - Creator:', userAddress);
                console.log('  - Token:', CONFIG.tokenId);
                console.log('  - Supplier:', supplierAddress);
                console.log('  - Goal:', goalXlm, 'XLM');
                console.log('  - Deadline:', new Date(deadline * 1000).toLocaleString());
                
                // Debug: Verificar tipos de argumentos
                console.log('üîç Verificando tipos de argumentos:');
                console.log('  - creatorScVal:', creatorScVal);
                console.log('  - tokenScVal:', tokenScVal);
                console.log('  - supplierScVal:', supplierScVal);
                console.log('  - goalScVal:', goalScVal);
                console.log('  - deadlineScVal:', deadlineScVal);
                
                console.log('üî® Construyendo transacci√≥n...');
                
                // 1) Construir operaci√≥n
                const operation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'create_pool',
                    args: [
                        creatorScVal,  // creator: Address
                        tokenScVal,    // token: Address
                        supplierScVal, // supplier: Address
                        goalScVal,     // goal: i128
                        deadlineScVal  // deadline: u64
                    ]
                });

                // 2) Armar transacci√≥n base
                let transaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(operation)
                .setTimeout(600) // 10 minutos para dar tiempo a Freighter
                .build();

                console.log('‚úÖ Transacci√≥n construida exitosamente');

                // 3) Simular y preparar (footprint + resource fee + auth)
                console.log('üîç Simulando transacci√≥n...');
                const simulation = await server.simulateTransaction(transaction);
                console.log('üìä Simulaci√≥n:', simulation);
                
                if (simulation.error) {
                    throw new Error('Error en simulaci√≥n: ' + simulation.error);
                }

                console.log('üîß Preparando transacci√≥n...');
                transaction = await server.prepareTransaction(transaction);
                console.log('‚úÖ Transacci√≥n preparada con footprint y autorizaci√≥n');

                console.log('‚úçÔ∏è Firmando transacci√≥n...');
                
                // Actualizar estado visual
                setProcessStep(2);
                updateProcessStatus('Firmando con Freighter...');
                
                await sendLogToServer('info', 'Firmando transacci√≥n con Freighter', null, 'CREATE_POOL');
                
                const signedTransaction = await window.freighter.signTransaction(transaction.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress  // unifica: usa 'address' para ser consistente
                });

                if (signedTransaction.error) {
                    console.error('‚ùå Error de Freighter:', signedTransaction.error);
                    await sendErrorLog(signedTransaction.error, 'Error firmando transacci√≥n', null);
                    
                    let errorMessage = 'Error firmando transacci√≥n';
                    if (typeof signedTransaction.error === 'string') {
                        errorMessage = signedTransaction.error;
                    } else if (signedTransaction.error.message) {
                        errorMessage = signedTransaction.error.message;
                    } else {
                        errorMessage = JSON.stringify(signedTransaction.error);
                    }
                    
                    throw new Error(errorMessage);
                }

                console.log('üì§ Enviando transacci√≥n...');
                
                // Actualizar estado visual
                setProcessStep(3);
                updateProcessStatus('Enviando a la red...');
                
                // 4) Enviar - usar fallback para ambas variantes de Freighter
                const signedXdr = signedTransaction.signedTxXdr ?? signedTransaction.signedXDR;
                if (!signedXdr) {
                    throw new Error('Freighter no retorn√≥ XDR firmada (signedTxXdr/signedXDR)');
                }
                
                const transactionToSubmit = StellarSdk.TransactionBuilder.fromXDR(
                    signedXdr,
                    CONFIG.networkPassphrase
                );

                const response = await server.sendTransaction(transactionToSubmit);
                console.log('üìä Respuesta completa:', response);
                console.log('üìä Status:', response.status);

                if (response.status === 'SUCCESS') {
                    // Actualizar estado visual
                    setProcessStep(5);
                    updateProcessStatus('Procesando resultado...', false);
                    
                    await sendTransactionLog('CREATE_POOL', {
                        poolId: response.id,
                        supplier: supplierAddress,
                        goal: goalXlm,
                        deadline: new Date(deadline * 1000).toISOString()
                    }, 'success');
                    
                    showAlert(`‚úÖ Pool creado exitosamente! ID: ${response.id}`, 'success');
                    
                    // Cargar informaci√≥n del pool reci√©n creado
                    const poolId = response.id || await getPoolIdFromTx(response.hash);
                    if (poolId) {
                        await getPoolInfo(poolId);
                    }
                    
                    // Limpiar formulario y ocultar panel
                    document.getElementById('supplier').value = '';
                    document.getElementById('goal').value = '100';
                    document.getElementById('days').value = '30';
                    hideProcessPanel();
                    
                } else if (response.status === 'PENDING') {
                    // Actualizar estado visual
                    setProcessStep(4);
                    updateProcessStatus('Esperando confirmaci√≥n...');
                    showProcessHash(response.hash);
                    
                    // Almacenar hash para verificaci√≥n posterior
                    storeLastTransaction(response.hash);
                    showAlert(`‚è≥ Transacci√≥n pendiente\nHash: ${response.hash}\nEsperando confirmaci√≥n...`, 'info');

                    try {
                        // Usar watcher autom√°tico
                        const final = await waitForTx(response.hash);
                        if (final.status === 'SUCCESS') {
                            // Actualizar estado visual
                            setProcessStep(5);
                            updateProcessStatus('¬°Pool confirmado!', false);
                            
                            showAlert('‚úÖ ¬°Pool confirmado on-chain!', 'success');
                            
                            // Extraer poolId y cargar informaci√≥n
                            const poolId = await getPoolIdFromTx(response.hash);
                            
                            if (poolId) {
                                await getPoolInfo(poolId);
                                // Limpiar formulario y ocultar panel
                                document.getElementById('supplier').value = '';
                                document.getElementById('goal').value = '100';
                                document.getElementById('days').value = '30';
                                setTimeout(() => hideProcessPanel(), 2000);
                            } else {
                                showAlert('‚ö†Ô∏è Pool creado pero no se pudo obtener el ID', 'warning');
                                hideProcessPanel();
                            }
                        } else {
                            updateProcessStatus('Transacci√≥n fall√≥', false);
                            showAlert('‚ùå La transacci√≥n fall√≥', 'danger');
                            console.error('Detalles del error:', final);
                            setTimeout(() => hideProcessPanel(), 3000);
                        }
                    } catch (e) {
                        updateProcessStatus('Expir√≥ la espera', false);
                        showAlert('‚åõ Expir√≥ la espera de confirmaci√≥n', 'warning');
                        console.error('Error en watcher:', e);
                        setTimeout(() => hideProcessPanel(), 3000);
                    }
                } else {
                    await sendTransactionLog('CREATE_POOL', {
                        supplier: supplierAddress,
                        goal: goalXlm,
                        deadline: new Date(deadline * 1000).toISOString()
                    }, 'error', response.status);
                    
                    // Mostrar error m√°s espec√≠fico
                    let errorMessage = 'La transacci√≥n fall√≥: ' + response.status;
                    if (response.errorResult) {
                        console.log('‚ùå Error details:', JSON.stringify(response.errorResult));
                        errorMessage += '\nDetalles: ' + JSON.stringify(response.errorResult);
                        
                        // Analizar tipo de error espec√≠fico
                        if (response.errorResult.result && response.errorResult.result._switch) {
                            const errorType = response.errorResult.result._switch.name;
                            console.log('üîç Tipo de error:', errorType);
                            
                            if (errorType === 'txMalformed') {
                                errorMessage += '\nüí° Error: Transacci√≥n malformada. Verifica los argumentos del contrato.';
                            } else if (errorType === 'txFailed') {
                                errorMessage += '\nüí° Error: Transacci√≥n fall√≥. Verifica que el contrato est√© inicializado.';
                            }
                        }
                    }
                    throw new Error(errorMessage);
                }

            } catch (error) {
                console.error('‚ùå Error creando pool:', error.message);
                await sendErrorLog(error, 'Error en createPool', error.stack);
                
                // Ocultar panel de proceso en caso de error
                updateProcessStatus('Error en el proceso', false);
                setTimeout(() => hideProcessPanel(), 3000);
                
                let errorMessage = 'Error desconocido';
                if (error.message) {
                    errorMessage = error.message;
                } else if (typeof error === 'string') {
                    errorMessage = error;
                } else {
                    errorMessage = JSON.stringify(error);
                }
                
                showAlert('‚ùå Error creando pool: ' + errorMessage, 'danger');
            }
        }

        // Contribuir a un pool existente
        async function contributeToPool() {
            if (!isConnected || !userAddress) {
                showAlert('‚ùå Conecta la wallet para contribuir', 'danger');
                return;
            }

            try {
                // Obtener datos del formulario
                const poolId = parseInt(document.getElementById('contrib-pool-id').value);
                const amountXlm = parseFloat(document.getElementById('contrib-amount').value);

                // Validaciones
                if (!poolId || poolId <= 0) {
                    showAlert('‚ùå Ingresa un ID de pool v√°lido', 'danger');
                    return;
                }

                if (!Number.isFinite(amountXlm) || amountXlm <= 0) {
                    showAlert('‚ùå La cantidad debe ser mayor a 0 XLM', 'danger');
                    return;
                }

                // Convertir XLM a stroops (7 decimales para XLM)
                const amountStroops = BigInt(Math.round(amountXlm * 1e7));

                console.log('üí∞ Contribuyendo al pool...');
                console.log('üÜî Pool ID:', poolId);
                console.log('üíµ Cantidad:', amountXlm, 'XLM');

                // Mostrar panel de proceso
                showProcessPanel();
                setProcessStep(1);
                updateProcessStatus('Preparando aprobaci√≥n...');

                // Primero necesitamos aprobar el contrato para gastar nuestros XLM
                console.log('üîê Aprobando contrato para gastar XLM...');
                
                const account = await server.getAccount(userAddress);
                
                // Obtener ledger actual para expiration_ledger
                const { sequence } = await server.getLatestLedger();
                const expirationLedger = sequence + 1000; // 1000 ledgers de validez
                
                // 1) Construir operaci√≥n de approve (4 argumentos: from, spender, amount, expiration)
                // from = usuario que autoriza
                const fromAddr = StellarSdk.Address.fromString(userAddress);
                const fromScVal = StellarSdk.nativeToScVal(fromAddr, { type: 'address' });
                
                // spender = tu contrato (usar fromString para consistencia)
                const spenderAddr = StellarSdk.Address.fromString(CONFIG.contractId);
                const spenderScVal = StellarSdk.nativeToScVal(spenderAddr, { type: 'address' });
                
                // amount y expiration como ya tienes
                const amountScVal = StellarSdk.nativeToScVal(amountStroops, { type: 'i128' });
                const expScVal = StellarSdk.nativeToScVal(expirationLedger, { type: 'u32' });
                
                console.log('üîç Debug approve args (4 argumentos):');
                console.log('  - fromScVal:', fromScVal);
                console.log('  - spenderScVal:', spenderScVal);
                console.log('  - amountScVal:', amountScVal);
                console.log('  - expScVal:', expScVal);
                
                const approveOperation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.tokenId, // Token XLM
                    function: 'approve',
                    args: [fromScVal, spenderScVal, amountScVal, expScVal] // 4 args: from, spender, amount, expiration
                });

                // 2) Armar transacci√≥n base
                let approveTransaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(approveOperation)
                .setTimeout(600) // 10 minutos para dar tiempo a Freighter
                .build();

                // 3) Simular y preparar
                setProcessStep(2);
                updateProcessStatus('Simulando aprobaci√≥n...');
                console.log('üîç Simulando approve...');
                const approveSimulation = await server.simulateTransaction(approveTransaction);
                if (approveSimulation.error) {
                    throw new Error('Error en simulaci√≥n de approve: ' + approveSimulation.error);
                }

                setProcessStep(3);
                updateProcessStatus('Preparando aprobaci√≥n...');
                console.log('üîß Preparando approve...');
                approveTransaction = await server.prepareTransaction(approveTransaction);

                // 4) Firmar y enviar approve
                const signedApprove = await window.freighter.signTransaction(approveTransaction.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress  // unifica: usa 'address' para ser consistente
                });

                if (signedApprove.error) {
                    throw new Error('Error firmando approve: ' + signedApprove.error);
                }

                const approveSignedXdr = signedApprove.signedTxXdr ?? signedApprove.signedXDR;
                if (!approveSignedXdr) {
                    throw new Error('Freighter no retorn√≥ XDR firmada (signedTxXdr/signedXDR)');
                }

                const approveToSubmit = StellarSdk.TransactionBuilder.fromXDR(
                    approveSignedXdr,
                    CONFIG.networkPassphrase
                );

                const approveResponse = await server.sendTransaction(approveToSubmit);
                console.log('‚úÖ Approve enviado:', approveResponse);

                // Manejar PENDING usando waitForTx (como en createPool)
                if (approveResponse.status === 'PENDING') {
                    console.log('‚è≥ Approve pendiente, esperando confirmaci√≥n...');
                    const final = await waitForTx(approveResponse.hash);
                    if (final.status !== 'SUCCESS') {
                        throw new Error('Approve no se confirm√≥: ' + final.status);
                    }
                    console.log('‚úÖ Approve confirmado on-chain');
                } else if (approveResponse.status !== 'SUCCESS') {
                    throw new Error('Approve fall√≥: ' + approveResponse.status);
                }

                // Ahora crear la transacci√≥n de contribute
                setProcessStep(4);
                updateProcessStatus('Preparando contribuci√≥n...');
                console.log('üí∏ Enviando contribuci√≥n...');
                
                // 1) Construir operaci√≥n de contribute
                const userAddr = StellarSdk.Address.fromString(userAddress);
                const userScVal = StellarSdk.nativeToScVal(userAddr, { type: 'address' });
                const contributeOperation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'contribute',
                    args: [
                        StellarSdk.nativeToScVal(poolId, { type: 'u32' }), // pool_id
                        userScVal,                                         // user: Address
                        StellarSdk.nativeToScVal(amountStroops, { type: 'i128' }) // amount
                    ]
                });

                // 2) Armar transacci√≥n base
                let contributeTransaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(contributeOperation)
                .setTimeout(600) // 10 minutos para dar tiempo a Freighter
                .build();

                // 3) Simular y preparar
                console.log('üîç Simulando contribute...');
                const contributeSimulation = await server.simulateTransaction(contributeTransaction);
                if (contributeSimulation.error) {
                    throw new Error('Error en simulaci√≥n de contribute: ' + contributeSimulation.error);
                }

                console.log('üîß Preparando contribute...');
                contributeTransaction = await server.prepareTransaction(contributeTransaction);

                // 4) Firmar y enviar contribute
                const signedContribute = await window.freighter.signTransaction(contributeTransaction.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress  // unifica: usa 'address' para ser consistente
                });

                if (signedContribute.error) {
                    throw new Error('Error firmando contribute: ' + signedContribute.error);
                }

                const contributeSignedXdr = signedContribute.signedTxXdr ?? signedContribute.signedXDR;
                if (!contributeSignedXdr) {
                    throw new Error('Freighter no retorn√≥ XDR firmada (signedTxXdr/signedXDR)');
                }

                const contributeToSubmit = StellarSdk.TransactionBuilder.fromXDR(
                    contributeSignedXdr,
                    CONFIG.networkPassphrase
                );

                const contributeResponse = await server.sendTransaction(contributeToSubmit);
                console.log('‚úÖ Contribuci√≥n enviada:', contributeResponse);

                // Manejar PENDING usando waitForTx (como en createPool y approve)
                if (contributeResponse.status === 'PENDING') {
                    storeLastTransaction(contributeResponse.hash);
                    showProcessHash(contributeResponse.hash);
                    updateProcessStatus('‚è≥ Esperando confirmaci√≥n de contribuci√≥n...');
                    const final = await waitForTx(contributeResponse.hash);
                    if (final.status !== 'SUCCESS') {
                        throw new Error(`La contribuci√≥n fall√≥ on-chain: ${final.status}`);
                    }
                    console.log('‚úÖ Contribuci√≥n confirmada on-chain');
                } else if (contributeResponse.status !== 'SUCCESS') {
                    throw new Error(`La contribuci√≥n no fue aceptada: ${contributeResponse.status}`);
                }

                // Si llegamos aqu√≠, fue SUCCESS on-chain
                setProcessStep(5);
                updateProcessStatus('‚úÖ Contribuci√≥n confirmada');
                showAlert(`‚úÖ ¬°Contribuci√≥n exitosa! ${amountXlm} XLM al pool ${poolId}`, 'success');

                // üîÑ Refrescar la tarjeta del pool (con peque√±o retardo para consistencia eventual)
                try {
                    // Asegura que el selector de "Acciones" tambi√©n apunte a este pool
                    document.getElementById('action-pool-id').value = String(poolId);
                    // Peque√±o retardo para asegurar consistencia eventual
                    setTimeout(async () => {
                        try {
                            await getPoolInfo(poolId);   // <- vuelve a simular get_pool y re-renderiza
                        } catch (e) {
                            console.warn('No se pudo refrescar el pool autom√°ticamente:', e);
                        }
                    }, 1200);
                } catch (e) {
                    console.warn('Error configurando refresco del pool:', e);
                }
                
                // Limpiar formulario y ocultar panel
                document.getElementById('contrib-amount').value = '10';
                setTimeout(() => hideProcessPanel(), 2000);

            } catch (error) {
                console.error('‚ùå Error contribuyendo:', error);
                showAlert('‚ùå Error contribuyendo: ' + error.message, 'danger');
                setTimeout(() => hideProcessPanel(), 3000);
            }
        }

        // Finalizar un pool (solo el creador)
        async function finalizePool() {
            if (!isConnected || !userAddress) {
                showAlert('‚ùå Conecta la wallet para finalizar', 'danger');
                return;
            }

            try {
                const poolId = parseInt(document.getElementById('action-pool-id').value);

                if (!poolId || poolId <= 0) {
                    showAlert('‚ùå Ingresa un ID de pool v√°lido', 'danger');
                    return;
                }

                console.log('üèÅ Finalizando pool...');
                console.log('üÜî Pool ID:', poolId);

                const account = await server.getAccount(userAddress);
                
                // 1) Construir operaci√≥n
                const operation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'finalize',
                    args: [
                        StellarSdk.nativeToScVal(poolId, { type: 'u32' }) // pool_id
                    ]
                });

                // 2) Armar transacci√≥n base
                let transaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(operation)
                .setTimeout(600) // 10 minutos para dar tiempo a Freighter
                .build();

                // 3) Simular y preparar
                console.log('üîç Simulando finalizaci√≥n...');
                const simulation = await server.simulateTransaction(transaction);
                if (simulation.error) {
                    throw new Error('Error en simulaci√≥n: ' + simulation.error);
                }

                console.log('üîß Preparando finalizaci√≥n...');
                transaction = await server.prepareTransaction(transaction);

                // 4) Firmar y enviar
                const signedTransaction = await window.freighter.signTransaction(transaction.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress  // unifica: usa 'address' para ser consistente
                });

                if (signedTransaction.error) {
                    throw new Error(signedTransaction.error);
                }

                const signedXdr = signedTransaction.signedTxXdr ?? signedTransaction.signedXDR;
                if (!signedXdr) {
                    throw new Error('Freighter no retorn√≥ XDR firmada (signedTxXdr/signedXDR)');
                }

                const transactionToSubmit = StellarSdk.TransactionBuilder.fromXDR(
                    signedXdr,
                    CONFIG.networkPassphrase
                );

                const response = await server.sendTransaction(transactionToSubmit);
                console.log('‚úÖ Pool finalizado:', response);

                if (response.status === 'SUCCESS') {
                    showAlert(`‚úÖ Pool ${poolId} finalizado exitosamente!`, 'success');
                } else {
                    throw new Error('La finalizaci√≥n fall√≥: ' + response.status);
                }

            } catch (error) {
                console.error('‚ùå Error finalizando pool:', error);
                showAlert('‚ùå Error finalizando pool: ' + error.message, 'danger');
            }
        }

        // Solicitar reembolso de un pool fallido
        async function requestRefund() {
            if (!isConnected || !userAddress) {
                showAlert('‚ùå Conecta la wallet para solicitar reembolso', 'danger');
                return;
            }

            try {
                const poolId = parseInt(document.getElementById('action-pool-id').value);

                if (!poolId || poolId <= 0) {
                    showAlert('‚ùå Ingresa un ID de pool v√°lido', 'danger');
                    return;
                }

                console.log('üí∞ Solicitando reembolso...');
                console.log('üÜî Pool ID:', poolId);

                const account = await server.getAccount(userAddress);
                
                // 1) Construir operaci√≥n
                const operation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'refund',
                    args: [
                        StellarSdk.nativeToScVal(poolId, { type: 'u32' }) // pool_id
                    ]
                });

                // 2) Armar transacci√≥n base
                let transaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(operation)
                .setTimeout(600) // 10 minutos para dar tiempo a Freighter
                .build();

                // 3) Simular y preparar
                console.log('üîç Simulando reembolso...');
                const simulation = await server.simulateTransaction(transaction);
                if (simulation.error) {
                    throw new Error('Error en simulaci√≥n: ' + simulation.error);
                }

                console.log('üîß Preparando reembolso...');
                transaction = await server.prepareTransaction(transaction);

                // 4) Firmar y enviar
                const signedTransaction = await window.freighter.signTransaction(transaction.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress  // unifica: usa 'address' para ser consistente
                });

                if (signedTransaction.error) {
                    throw new Error(signedTransaction.error);
                }

                const signedXdr = signedTransaction.signedTxXdr ?? signedTransaction.signedXDR;
                if (!signedXdr) {
                    throw new Error('Freighter no retorn√≥ XDR firmada (signedTxXdr/signedXDR)');
                }

                const transactionToSubmit = StellarSdk.TransactionBuilder.fromXDR(
                    signedXdr,
                    CONFIG.networkPassphrase
                );

                const response = await server.sendTransaction(transactionToSubmit);
                console.log('‚úÖ Reembolso solicitado:', response);

                if (response.status === 'SUCCESS') {
                    showAlert(`‚úÖ Reembolso exitoso para el pool ${poolId}!`, 'success');
                } else {
                    throw new Error('El reembolso fall√≥: ' + response.status);
                }

            } catch (error) {
                console.error('‚ùå Error solicitando reembolso:', error);
                showAlert('‚ùå Error solicitando reembolso: ' + error.message, 'danger');
            }
        }

        // Consultar informaci√≥n de un pool (read-only, sin firmar)
        async function getPoolInfo(poolId = null) {
            if (!isConnected) {
                showAlert('‚ùå Conecta la wallet para ver informaci√≥n', 'danger');
                return;
            }

            try {
                // Si no se pasa poolId, obtenerlo del formulario
                if (!poolId) {
                    poolId = parseInt(document.getElementById('action-pool-id').value);
                    if (!poolId || poolId <= 0) {
                        showAlert('‚ùå Ingresa un ID de pool v√°lido', 'danger');
                        return;
                    }
                }

                console.log('üîç Consultando pool (read-only)...');
                console.log('üÜî Pool ID:', poolId);

                const account = await server.getAccount(userAddress);
                
                // 1) Construir operaci√≥n
                const operation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'get_pool',
                    args: [
                        StellarSdk.nativeToScVal(poolId, { type: 'u32' }) // pool_id
                    ]
                });

                // 2) Armar transacci√≥n base
                let transaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(operation)
                .setTimeout(600) // 10 minutos para dar tiempo a Freighter
                .build();

                // 3) Solo simular (read-only)
                console.log('üîç Simulando consulta de pool...');
                const simulation = await server.simulateTransaction(transaction);
                if (simulation.error) {
                    throw new Error('Error en simulaci√≥n: ' + simulation.error);
                }

                // Decodificar el returnValue (ScVal -> JS)
                const scv = simulation.result?.retval ?? simulation.result?.returnValue ?? simulation.returnValue;
                if (!scv) {
                    throw new Error('Sin returnValue en la simulaci√≥n');
                }

                const pool = StellarSdk.scValToNative(scv);
                console.log('üìä Datos del pool (decodificado):', pool);

                // Calcular estado del pool
                const now = Math.floor(Date.now() / 1000);
                const expired = now > pool.deadline;
                const funded = BigInt(pool.raised) >= BigInt(pool.goal);
                const status = pool.finalized ? 'finalized'
                             : expired && !funded ? 'expired'
                             : funded ? 'funded'
                             : 'active';

                // Renderizar tarjeta del pool
                renderPoolCard(poolId, pool, status);

                return { pool, status };

            } catch (error) {
                console.error('‚ùå Error consultando pool:', error);
                showAlert('‚ùå Error consultando pool: ' + error.message, 'danger');
                return null;
            }
        }

        // Renderizar tarjeta del pool en la UI
        function renderPoolCard(poolId, pool, status) {
            const poolsList = document.getElementById('pools-list');
            
            // Crear o actualizar tarjeta del pool
            let poolCard = document.getElementById(`pool-${poolId}`);
            if (!poolCard) {
                poolCard = document.createElement('div');
                poolCard.id = `pool-${poolId}`;
                poolCard.className = 'pool-card';
                poolsList.appendChild(poolCard);
            }

            // Calcular progreso
            const progress = Number(pool.raised) / Number(pool.goal) * 100;
            const goalXlm = Number(pool.goal) / 10000000;
            const raisedXlm = Number(pool.raised) / 10000000;
            const deadline = new Date(Number(pool.deadline) * 1000);

            // Mapear estados a clases CSS
            const statusClass = {
                'active': 'status-active',
                'funded': 'status-funded', 
                'finalized': 'status-funded',
                'expired': 'status-expired'
            }[status] || 'status-active';

            const statusText = {
                'active': 'Activo',
                'funded': 'Financiado',
                'finalized': 'Finalizado',
                'expired': 'Expirado'
            }[status] || 'Activo';

            poolCard.innerHTML = `
                <div class="pool-header">
                    <span class="pool-id">Pool #${poolId}</span>
                    <span class="pool-status ${statusClass}">${statusText}</span>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${Math.min(progress, 100)}%"></div>
                </div>
                
                <div class="pool-info">
                    <div class="info-item">
                        <div class="info-label">Meta</div>
                        <div class="info-value">${goalXlm} XLM</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Recaudado</div>
                        <div class="info-value">${raisedXlm} XLM</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Progreso</div>
                        <div class="info-value">${progress.toFixed(1)}%</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Deadline</div>
                        <div class="info-value">${deadline.toLocaleDateString()}</div>
                    </div>
                </div>
            `;
        }

        // --- Intenta extraer poolId desde el returnValue
        async function getPoolIdFromReturnValue(hash) {
            try {
                const tx = await safeGetTransaction(hash);
                if (tx.status !== 'SUCCESS') return null;

                // posibles ubicaciones del retorno seg√∫n SDK/RPC
                const raw = tx.returnValue ?? tx.result?.retval ?? tx.result?.returnValue;
                const scv = toScVal(raw);
                if (!scv) return null;

                const native = StellarSdk.scValToNative(scv);
                const id = (native && typeof native === 'object' && 'id' in native) ? native.id : native;
                const n = Number(id);
                return Number.isFinite(n) ? n : null;
            } catch (e) {
                console.error('Error extrayendo poolId (returnValue):', e);
                return null;
            }
        }

        // --- Fallback: leer poolId desde eventos de la TX
        async function getPoolIdFromEventsByTx(hash) {
            try {
                const tx = await safeGetTransaction(hash);
                if (tx.status !== 'SUCCESS') return null;

                const ev = await server.getEvents({
                    startLedger: tx.ledger,
                    filters: [{ type: 'contract', contractIds: [CONFIG.contractId] }],
                });

                const event = ev.events.find(e => e.txHash === hash);
                if (!event) return null;

                // value puede estar en varias formas seg√∫n el endpoint
                const raw = event?.value?.xdr || event?.value || event?.data?.xdr || event?.data;
                const scv = toScVal(raw);
                if (!scv) return null;

                const native = StellarSdk.scValToNative(scv);
                const id = (native && typeof native === 'object' && 'id' in native) ? native.id : native;
                const n = Number(id);
                return Number.isFinite(n) ? n : null;
            } catch (e) {
                console.error('Error extrayendo poolId (eventos):', e);
                return null;
            }
        }

        // --- Agregador: dame el poolId como sea
        async function getPoolIdFromTx(hash) {
            let id = await getPoolIdFromReturnValue(hash);
            if (!id) id = await getPoolIdFromEventsByTx(hash);

            // √∫ltimo recurso: si tu contrato guarda NextPoolId, puedes leerlo y restar 1
            // id = id ?? await getLastPoolIdByCounter(); // (opcional)
            return id;
        }

        function loadActivePools() {
            if (!isConnected) {
                showAlert('‚ùå Conecta la wallet para cargar pools', 'danger');
                return;
            }
            showAlert('üöß Funci√≥n cargar pools en desarrollo...', 'info');
        }

        // Verificar estado de transacci√≥n por hash
        async function checkTransactionStatus() {
            const hash = prompt('Ingresa el hash de la transacci√≥n:');
            if (!hash) return;

            try {
                console.log('üîç Verificando estado de transacci√≥n...');
                console.log('üìã Hash:', hash);

                const response = await server.getTransaction(hash);
                console.log('üìä Estado de transacci√≥n:', response);

                if (response.status === 'SUCCESS') {
                    showAlert(`‚úÖ Transacci√≥n exitosa!\nHash: ${hash}\nLedger: ${response.ledger}`, 'success');
                } else if (response.status === 'PENDING') {
                    showAlert(`‚è≥ Transacci√≥n pendiente\nHash: ${hash}\n√öltimo ledger: ${response.latestLedger}`, 'info');
                } else if (response.status === 'ERROR') {
                    showAlert(`‚ùå Transacci√≥n fall√≥\nHash: ${hash}\nError: ${JSON.stringify(response.errorResult)}`, 'danger');
                } else {
                    showAlert(`‚ÑπÔ∏è Estado: ${response.status}\nHash: ${hash}`, 'info');
                }

            } catch (error) {
                console.error('‚ùå Error verificando transacci√≥n:', error);
                showAlert('‚ùå Error verificando transacci√≥n: ' + error.message, 'danger');
            }
        }

        // Verificar estado de la √∫ltima transacci√≥n (si est√° almacenada)
        let lastTransactionHash = null;

        // Guarda el hash para la UI y para reintentos tras refresh
        function storeLastTransaction(hash) {
            lastTransactionHash = hash;
            localStorage.setItem('lastTxHash', hash);
            console.log('üíæ Hash almacenado:', hash);
        }

        // Cargar hash desde localStorage al inicializar
        function loadLastTransaction() {
            const stored = localStorage.getItem('lastTxHash');
            if (stored) {
                lastTransactionHash = stored;
                console.log('üìÇ Hash cargado desde localStorage:', stored);
            }
        }

        // Funciones para manejar el estado visual del proceso
        function showProcessPanel() {
            const panel = document.getElementById('process-status-panel');
            panel.style.display = 'block';
            resetProcessSteps();
        }

        function hideProcessPanel() {
            const panel = document.getElementById('process-status-panel');
            panel.style.display = 'none';
        }

        function resetProcessSteps() {
            for (let i = 1; i <= 5; i++) {
                const step = document.getElementById(`process-step-${i}`);
                step.classList.remove('active', 'completed');
            }
        }

        function setProcessStep(stepNumber, status = 'active') {
            // Completar pasos anteriores
            for (let i = 1; i < stepNumber; i++) {
                const step = document.getElementById(`process-step-${i}`);
                step.classList.remove('active');
                step.classList.add('completed');
            }
            
            // Activar paso actual
            const currentStep = document.getElementById(`process-step-${stepNumber}`);
            currentStep.classList.remove('completed');
            currentStep.classList.add(status);
        }

        function updateProcessStatus(text, isActive = true) {
            const statusText = document.getElementById('process-status-text');
            const statusBadge = document.getElementById('process-status-badge');
            
            statusText.textContent = text;
            
            if (isActive) {
                statusBadge.style.background = 'rgba(255, 255, 255, 0.2)';
            } else {
                statusBadge.style.background = 'rgba(34, 197, 94, 0.2)';
            }
        }

        function showProcessHash(hash) {
            const hashDisplay = document.getElementById('process-hash-display');
            const hashValue = document.getElementById('process-hash-value');
            
            hashValue.textContent = hash;
            hashDisplay.style.display = 'block';
        }

        function hideProcessHash() {
            const hashDisplay = document.getElementById('process-hash-display');
            hashDisplay.style.display = 'none';
        }

        // --- Helper: llamada cruda al RPC (asegura usar "hash")
        async function rawGetTransactionStatus(rpcUrl, hash) {
            const h = String(hash).trim();
            if (h.length !== 64) throw new Error(`hash inv√°lido (${h.length} chars)`);
            const body = { jsonrpc: "2.0", id: 1, method: "getTransaction", params: { hash: h } };
            const r = await fetch(rpcUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
            const j = await r.json();
            if (j?.error) throw new Error(j.error.message || "RPC error");
            return {
                status: j?.result?.status ?? "NOT_FOUND",
                ledger: j?.result?.ledger,
                latestLedger: j?.result?.latestLedger,
                latestLedgerCloseTime: j?.result?.latestLedgerCloseTime,
                returnValue: j?.result?.returnValue // algunos RPC lo incluyen
            };
        }

        // --- Helper: intenta SDK y si falla usa RPC crudo
        async function safeGetTransaction(hash) {
            try { 
                return await server.getTransaction(hash); 
            } catch (e) { 
                console.warn('getTransaction SDK fall√≥, usando RPC crudo:', e?.message || e);
                return await rawGetTransactionStatus(CONFIG.sorobanRpcUrl, hash);
            }
        }

        // --- Helper: normaliza un ScVal venga como venga
        function toScVal(scvLike) {
            if (!scvLike) return null;
            try {
                if (scvLike instanceof StellarSdk.xdr.ScVal) return scvLike;
                if (typeof scvLike === 'string') return StellarSdk.xdr.ScVal.fromXDR(scvLike, 'base64');
                if (typeof scvLike === 'object' && typeof scvLike.xdr === 'string')
                    return StellarSdk.xdr.ScVal.fromXDR(scvLike.xdr, 'base64');
            } catch (e) {
                console.warn('toScVal: no se pudo convertir', e);
            }
            return null;
        }

        // Poll de estado de transacci√≥n (Soroban RPC) - Versi√≥n robusta con fallback
        async function waitForTx(hash, { intervalMs = 2500, maxMs = 180000 } = {}) {
            const start = Date.now();
            console.log(`üîÑ Iniciando watcher para hash: ${hash}`);
            
            while (true) {
                try {
                    let res;
                    try {
                        // 1) Intento normal con el SDK
                        res = await server.getTransaction(hash);
                    } catch (sdkErr) {
                        console.warn('‚ö†Ô∏è getTransaction (SDK) fall√≥, usando RPC crudo:', sdkErr?.message || sdkErr);
                        // 2) Fallback "crudo" sin decodificar XDR
                        res = await rawGetTransactionStatus(CONFIG.sorobanRpcUrl, hash);
                    }

                    console.log(`üìä Estado actual: ${res.status}`);

                    // NOT_FOUND | PENDING | SUCCESS | FAILED
                    if (res.status === 'SUCCESS' || res.status === 'FAILED') {
                        console.log(`‚úÖ Watcher completado: ${res.status}`);
                        return res;
                    }

                    if (Date.now() - start > maxMs) {
                        throw new Error('Timeout esperando confirmaci√≥n');
                    }
                    await new Promise(r => setTimeout(r, intervalMs));
                } catch (error) {
                    console.error('‚ùå Error en watcher:', error);
                    if (Date.now() - start > maxMs) throw error;
                    await new Promise(r => setTimeout(r, intervalMs));
                }
            }
        }

        async function checkLastTransaction() {
            if (!lastTransactionHash) {
                showAlert('‚ùå No hay transacci√≥n reciente para verificar', 'danger');
                return;
            }

            try {
                console.log('üîç Verificando √∫ltima transacci√≥n...');
                console.log('üìã Hash:', lastTransactionHash);

                const response = await safeGetTransaction(lastTransactionHash);

                console.log('üìä Estado de transacci√≥n:', response);

                if (response.status === 'SUCCESS') {
                    showAlert(`‚úÖ ¬°Transacci√≥n exitosa!\nHash: ${lastTransactionHash}\nLedger: ${response.ledger}`, 'success');
                } else if (response.status === 'PENDING') {
                    showAlert(`‚è≥ Transacci√≥n pendiente\nHash: ${lastTransactionHash}\n√öltimo ledger: ${response.latestLedger}`, 'info');
                } else if (response.status === 'ERROR') {
                    showAlert(`‚ùå Transacci√≥n fall√≥\nHash: ${lastTransactionHash}\nError: ${JSON.stringify(response.errorResult)}`, 'danger');
                } else {
                    showAlert(`‚ÑπÔ∏è Estado: ${response.status}\nHash: ${lastTransactionHash}`, 'info');
                }

            } catch (error) {
                console.error('‚ùå Error verificando transacci√≥n:', error);
                showAlert('‚ùå Error verificando transacci√≥n: ' + error.message, 'danger');
            }
        }

        // Inicializar cuando se carga la p√°gina
        window.addEventListener('load', init);
    </script>
</body>
</html>
                                
