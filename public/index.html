<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agro Coop - Cooperativa Rural del Sur</title>
    <script src="https://unpkg.com/@stellar/stellar-sdk@12.1.0/dist/stellar-sdk.min.js"></script>
    <script type="module">
        // Importar Freighter API usando ES6 modules como indica la documentación oficial
        import freighterApi from 'https://cdn.skypack.dev/@stellar/freighter-api';
        
        // Hacer disponible globalmente para compatibilidad
        window.freighterApi = freighterApi;
        window.freighter = freighterApi; // Alias para compatibilidad
        
        // Freighter API importado
        
        // Disparar evento personalizado cuando esté listo
        window.dispatchEvent(new CustomEvent('freighter-ready'));
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: linear-gradient(135deg, #2d5016 0%, #4a7c59 25%, #6b8e23 50%, #8fbc8f 75%, #98fb98 100%);
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(255,255,255,0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255,255,255,0.1) 0%, transparent 50%),
                linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.05) 50%, transparent 70%);
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }
        
        .container {
            max-width: 100%;
            width: 100%;
            margin: 0;
            background: linear-gradient(145deg, #f5f5dc 0%, #f0e68c 100%);
            border-radius: 0;
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.15),
                inset 0 1px 0 rgba(255,255,255,0.3);
            padding: 30px;
            border: none;
            min-height: 100vh;
            box-sizing: border-box;
        }
        
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 40px;
            padding: 30px 20px;
            border-bottom: 3px solid #8b4513;
            background: linear-gradient(90deg, transparent 0%, rgba(139,69,19,0.1) 50%, transparent 100%);
            position: relative;
            max-width: 1800px;
            margin-left: auto;
            margin-right: auto;
        }

        .header-logo {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
        }

        .header-content {
            text-align: center;
        }
        
        
        .header::after {
            content: "";
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 2em;
            animation: sway 3s ease-in-out infinite reverse;
        }
        
        @keyframes sway {
            0%, 100% { transform: translateY(-50%) rotate(-2deg); }
            50% { transform: translateY(-50%) rotate(2deg); }
        }
        
        .header h1 {
            color: #2d5016;
            font-size: 2.8em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-weight: bold;
        }
        
        .header p {
            color: #4a7c59;
            font-size: 1.2em;
            font-style: italic;
        }
        
        .wallet-section {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(145deg, #f0e68c 0%, #daa520 100%);
            border-radius: 15px;
            padding: 15px 20px;
            text-align: center;
            border: 2px solid #8b4513;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            min-width: 200px;
        }
        
        .wallet-section h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: #2d5016;
        }
        
        .wallet-status {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        
        .wallet-connect-btn {
            background: linear-gradient(145deg, #8b4513 0%, #a0522d 100%);
            color: #f5f5dc;
            border: 2px solid #654321;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .wallet-connect-btn:hover {
            background: linear-gradient(145deg, #a0522d 0%, #8b4513 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .wallet-address-display {
            background: linear-gradient(135deg, #2d5016 0%, #4a7c59 100%);
            color: #f5f5dc;
            padding: 8px 12px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #8b4513;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .wallet-address-display:hover {
            background: linear-gradient(135deg, #4a7c59 0%, #2d5016 100%);
            transform: scale(1.02);
        }
        
        .wallet-disconnect-btn {
            background: linear-gradient(145deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: 2px solid #bd2130;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .wallet-disconnect-btn:hover {
            background: linear-gradient(145deg, #c82333 0%, #dc3545 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .wallet-info {
            background: linear-gradient(145deg, #f0e68c 0%, #daa520 100%);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
            border: 2px solid #8b4513;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .wallet-info h4 {
            margin: 0 0 10px 0;
            color: #2d5016;
            font-weight: bold;
        }

        .wallet-info p {
            margin: 5px 0;
            color: #4a7c59;
            font-weight: 500;
        }

        .wallet-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Estilos para el panel de dirección de wallet */
        .wallet-address-panel {
            background: linear-gradient(135deg, #2d5016 0%, #4a7c59 100%);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            color: #f5f5dc;
            border: 2px solid #8b4513;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .wallet-address-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .wallet-address-header h4 {
            margin: 0;
            color: white;
            font-size: 1.2em;
        }

        .connection-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .badge-dot {
            width: 8px;
            height: 8px;
            background: #4ade80;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .wallet-address-content {
            margin-bottom: 20px;
        }

        .address-section {
            margin-bottom: 15px;
        }

        .address-section label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.9);
        }

        .address-display {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.2);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .address-display code {
            flex: 1;
            background: none;
            color: #fbbf24;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            word-break: break-all;
            padding: 0;
        }

        .btn-copy {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .btn-copy:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .address-short {
            margin-top: 8px;
            text-align: center;
        }

        .address-short span {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
        }

        .network-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .network-section label {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
        }

        .network-badge {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: 600;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
            color: white;
        }

        .status-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .status-connected {
            background: #d4edda;
            color: #155724;
        }

        .status-disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .status-loading {
            background: #fff3cd;
            color: #856404;
        }

        
        
        .btn {
            background: linear-gradient(145deg, #8b4513 0%, #a0522d 100%);
            color: #f5f5dc;
            border: 2px solid #654321;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .btn:hover {
            background: linear-gradient(145deg, #a0522d 0%, #8b4513 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-success {
            background: #28a745;
        }
        
        .btn-success:hover {
            background: #218838;
        }
        
        .btn-danger {
            background: #dc3545;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .section {
            background: linear-gradient(145deg, #f0e68c 0%, #daa520 100%);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 2px solid #8b4513;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .section.full-width {
            max-width: 1800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .section h3 {
            color: #2d5016;
            margin-bottom: 15px;
            font-size: 1.5em;
            font-weight: bold;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2d5016;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #8b4513;
            border-radius: 8px;
            background: #f5f5dc;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #8b4513;
            box-shadow: 0 0 0 3px rgba(139, 69, 19, 0.2);
            background: #fff8dc;
        }
        
        .pool-card {
            background: linear-gradient(145deg, #f5f5dc 0%, #f0e68c 100%);
            border: 2px solid #8b4513;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .pool-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        /* Carrusel Styles */
        .carousel-container {
            position: relative;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 50px;
        }

        .carousel-wrapper {
            overflow: hidden;
            border-radius: 15px;
        }

        .carousel-track {
            display: flex;
            transition: transform 0.5s ease-in-out;
            gap: 20px;
        }

        .carousel-card {
            flex: 0 0 calc(33.333% - 14px);
            background: linear-gradient(145deg, #f5f5dc 0%, #f0e68c 100%);
            border: 2px solid #8b4513;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            min-height: 280px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .carousel-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .carousel-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%);
            border: 2px solid #654321;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 10;
        }

        .carousel-btn:hover {
            background: linear-gradient(135deg, #a0522d 0%, #8b4513 100%);
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .carousel-btn-left {
            left: 10px;
        }

        .carousel-btn-right {
            right: 10px;
        }

        .carousel-dots {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .carousel-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #8b4513;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.5;
        }

        .carousel-dot.active {
            opacity: 1;
            transform: scale(1.2);
            background: #654321;
        }

        .carousel-dot:hover {
            opacity: 0.8;
            transform: scale(1.1);
        }

        .prefab-icon {
            width: 40px;
            height: 40px;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .carousel-card {
                flex: 0 0 calc(50% - 10px);
                min-height: 250px;
            }
            
            .carousel-container {
                padding: 0 40px;
            }
        }

        @media (max-width: 480px) {
            .carousel-card {
                flex: 0 0 100%;
                min-height: 220px;
            }
            
            .carousel-container {
                padding: 0 30px;
            }
        }

        /* Pools Scroll Styles */
        .pools-scroll-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px 0;
        }

        .pools-scroll-wrapper {
            overflow-x: auto;
            overflow-y: hidden;
            padding: 10px 0;
            scrollbar-width: thin;
            scrollbar-color: #8B4513 #f5f5dc;
        }

        .pools-scroll-wrapper::-webkit-scrollbar {
            height: 8px;
        }

        .pools-scroll-wrapper::-webkit-scrollbar-track {
            background: #f5f5dc;
            border-radius: 4px;
        }

        .pools-scroll-wrapper::-webkit-scrollbar-thumb {
            background: #8B4513;
            border-radius: 4px;
        }

        .pools-scroll-wrapper::-webkit-scrollbar-thumb:hover {
            background: #A0522D;
        }

        .pools-grid {
            display: flex;
            gap: 20px;
            padding: 0 10px;
            min-width: max-content;
        }

        .pool-card-scroll {
            flex: 0 0 300px;
            background: linear-gradient(145deg, #f5f5dc 0%, #f0e68c 100%);
            border: 2px solid #8B4513;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            min-height: 280px;
        }

        .pool-card-scroll:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        @media (max-width: 768px) {
            .pool-card-scroll {
                flex: 0 0 280px;
                min-height: 260px;
            }
        }

        @media (max-width: 480px) {
            .pool-card-scroll {
                flex: 0 0 250px;
                min-height: 240px;
            }
        }

        /* Sistema de Notificaciones Flotantes */
        .notifications-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .notification {
            background: white;
            border: 2px solid #8B4513;
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            min-width: 300px;
            max-width: 400px;
            display: flex;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            position: relative;
            overflow: hidden;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.hide {
            opacity: 0;
            transform: translateX(100%);
        }

        .notification-icon {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
        }

        .notification.success .notification-icon {
            background: #28a745;
        }

        .notification.error .notification-icon {
            background: #dc3545;
        }

        .notification.warning .notification-icon {
            background: #ffc107;
            color: #212529;
        }

        .notification.info .notification-icon {
            background: #17a2b8;
        }

        .notification-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .notification-title {
            font-weight: 600;
            font-size: 14px;
            color: #333;
            margin: 0;
        }

        .notification-message {
            font-size: 13px;
            color: #666;
            margin: 0;
            line-height: 1.4;
        }

        .notification-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 18px;
            color: #999;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
            transition: color 0.2s;
        }

        .notification-close:hover {
            color: #333;
        }

        .notification-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: #8B4513;
            border-radius: 0 0 10px 10px;
            transition: width linear;
        }

        @media (max-width: 480px) {
            .notifications-container {
                top: 10px;
                right: 10px;
                left: 10px;
            }

            .notification {
                min-width: auto;
                max-width: none;
            }
        }
        
        .pool-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .pool-id {
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .pool-status {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .status-active {
            background: #d4edda;
            color: #155724;
        }
        
        .status-funded {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status-expired {
            background: #f8d7da;
            color: #721c24;
        }
        
        .progress-bar {
            background: #e9ecef;
            border-radius: 10px;
            height: 20px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #28a745, #20c997);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .pool-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .info-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
        }
        
        .info-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .info-value {
            font-weight: bold;
            color: #333;
        }
        
        .connected {
            color: #28a745;
            font-weight: bold;
        }
        
        .disconnected {
            color: #dc3545;
            font-weight: bold;
        }
        
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 30px;
            max-width: 1800px;
            margin: 0 auto;
        }
        
        @media (max-width: 1400px) {
            .grid {
                grid-template-columns: 1fr 1fr;
                gap: 25px;
            }
        }
        
        @media (max-width: 900px) {
            .grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .pool-info {
                grid-template-columns: 1fr;
            }
        }

        .pool-name {
            background: #667eea;
            color: #fff;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: .9em;
            font-weight: bold;
            max-width: 70%;          /* no invadir el badge de estado */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;  /* "…" si es muy largo */
            display: inline-block;
        }

        /* --- FAB borrar todas las pools --- */
        .fab-delete {
            position: fixed;
            right: 24px;
            bottom: 24px;
            z-index: 10001;    /* sobre todo */
        }

        /* Evita que el FAB tape contenido al fondo */
        .container { padding-bottom: 120px; }

        /* Apilar formularios y estirarlos */
        .grid.stack-forms {
            grid-template-columns: 1fr;    /* 1 columna en todas las resoluciones */
            gap: 24px;
            max-width: 1400px;             /* estirado pero controlado */
            margin-left: auto;
            margin-right: auto;
        }

        /* Que los paneles ocupen todo el ancho disponible del grid */
        .grid.stack-forms .section {
            width: 100%;
        }

        /* Inputs cómodos a lo ancho */
        .grid.stack-forms .form-group input,
        .grid.stack-forms .form-group select {
            width: 100%;
        }

        /* Botón principal con touch target cómodo */
        .grid.stack-forms .btn {
            min-width: 220px;
        }
    </style>
</head>
<body>
    <!-- Sistema de Notificaciones Flotantes -->
    <div id="notifications-container" class="notifications-container"></div>
    
    <div class="container">
        <div class="header">
            <img src="logo.png" alt="Agro Coop del Sur" class="header-logo" />
            <div class="header-content">
                <h1>Agro Coop del Sur</h1>
                <p>Cooperativa rural para compras colectivas de insumos agrícolas</p>
            </div>
        </div>

        <!-- Sección de Wallet - Esquina Superior Derecha -->
        <div class="wallet-section">
            <h3>🔗 Billetera</h3>
            <div class="wallet-status">
                <!-- Estado de conexión -->
                <div id="wallet-connect-state" style="display: none;">
                    <button class="wallet-connect-btn" id="connect-btn" onclick="connectWallet()">
                        🌾 Conectar
                    </button>
                    <button id="retry-btn" class="wallet-connect-btn" style="display:none" onclick="retryFreighterDetection()">
                        🔁 Reintentar Detección
                    </button>
                </div>
                
                <!-- Estado conectado -->
                <div id="wallet-connected-state" style="display: none;">
                    <div class="wallet-address-display" id="wallet-address-display" onclick="copyAddress()" title="Click para copiar">
                        <span id="wallet-address-short">GDSAGECL...2ILJS5FA</span>
                    </div>
                    <button class="wallet-disconnect-btn" id="disconnect-btn" onclick="disconnectWallet()">
                        🚪 Desconectar
                    </button>
                </div>
                
                <!-- Estado de carga -->
                <div id="wallet-loading-state">
                    <span id="status-indicator" class="status-indicator status-loading">🔄 Verificando...</span>
                </div>
            </div>
        </div>



        <!-- Cooperativas Activas - Home Principal -->
        <div class="section full-width">
            <h3>📊 Cooperativas Activas</h3>
            <button class="btn" onclick="loadActivePools()" id="load-pools-btn" disabled>
                📊 Cargar Cooperativas
            </button>
            <div class="pools-scroll-container" id="pools-scroll-container">
              <div class="pools-scroll-wrapper" id="pools-scroll-wrapper">
                <div class="pools-grid" id="pools-grid"></div>
              </div>
            </div>
        </div>

        <!-- Grid principal -->
        <div class="grid stack-forms">
            <!-- Crear Pool -->
            <div class="section">
                <h3>🌱 Crear Cooperativa</h3>
                <div class="form-group">
                    <label>Nombre de la Cooperativa:</label>
                    <input
                        type="text"
                        id="pool-name"
                        placeholder="Ej: Leña de invierno para la sede"
                        maxlength="20"
                    />
                    <small style="color:#666;font-size:0.9em;">Máx 20 caracteres</small>
                </div>
                <div class="form-group">
                    <label>Proveedor de Insumos:</label>
                    <input type="text" id="supplier" placeholder="GABC... dirección Stellar" />
                    <small style="color: #666; font-size: 0.9em;">Solo direcciones Stellar</small>
                </div>
                <div class="form-group">
                    <label>Meta de Recaudación (XLM):</label>
                    <input type="number" id="goal" placeholder="100" min="1" oninput="updateConversion('goal', 'goal-conversion')" />
                    <small id="goal-conversion" style="color: #666; font-size: 0.9em;">≈ $100.000 CLP</small>
                </div>
                <div class="form-group">
                    <label>Vence el:</label>
                    <input type="datetime-local" id="deadline" />
                    <small style="color: #666; font-size: 0.9em;">Fecha y hora de vencimiento</small>
                </div>
                <button class="btn btn-success" onclick="createPool()" id="create-btn" disabled>
                    🌱 Crear Cooperativa
                </button>
            </div>

            <!-- Contribuir -->
            <div class="section">
                <h3>🌾 Aportar a Cooperativa</h3>
                <div class="form-group">
                    <label>Cooperativa activa:</label>
                    <select id="contrib-pool-select" disabled>
                        <option value="">Cargar cooperativas activas (arriba)</option>
                    </select>
                    <!-- (Opcional) deja el input como fallback oculto -->
                    <input type="text" id="contrib-pool-id" style="display:none" />
                </div>
                <div class="form-group">
                    <label>Monto del Aporte (XLM):</label>
                    <input type="number" id="contrib-amount" placeholder="10" min="0.1" step="0.1" oninput="updateConversion('contrib-amount', 'contrib-conversion')" />
                    <small id="contrib-conversion" style="color: #666; font-size: 0.9em;">≈ $10.000 CLP</small>
                </div>
                <button class="btn" onclick="contributeToPool()" id="contrib-btn" disabled>
                    🌾 Aportar
                </button>
                <small style="color: #666; font-size: 0.9em; display: block; margin-top: 5px;">
                    Se te pedirá autorizar y luego confirmaremos tu aporte
                </small>
            </div>

            <!-- Acciones de Pool - Comentado: ahora se gestiona desde cada tarjeta -->
            <!--
            <div class="section">
                <h3>⚡ Gestionar Cooperativa</h3>
                <div class="form-group">
                    <label>Código de la Cooperativa:</label>
                    <input type="text" id="action-pool-id" placeholder="Pega el código o enlace aquí" />
                </div>
                <button class="btn btn-success" onclick="finalizePool()" id="finalize-btn" disabled>
                    💳 Pagar al Proveedor
                </button>
                <button class="btn btn-danger" onclick="requestRefund()" id="refund-btn" disabled>
                    💰 Obtener Reembolso
                </button>
            </div>
            -->
        </div>

        <!-- 🧩 Plantillas rápidas -->
        <div class="section full-width" id="prefab-section">
            <h3>🧩 Plantillas rápidas</h3>
            <div class="carousel-container">
                <button class="carousel-btn carousel-btn-left" onclick="moveCarousel(-1)">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="15,18 9,12 15,6"></polyline>
                    </svg>
                </button>
                
                <div class="carousel-wrapper">
                    <div class="carousel-track" id="carousel-track">
                        <!-- Las plantillas se generarán dinámicamente -->
                    </div>
                </div>
                
                <button class="carousel-btn carousel-btn-right" onclick="moveCarousel(1)">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="9,18 15,12 9,6"></polyline>
                    </svg>
                </button>
            </div>
            
            <div class="carousel-dots" id="carousel-dots">
                <!-- Los puntos se generarán dinámicamente -->
            </div>
        </div>

    </div>


    <script>
        // Configuración
        const CONFIG = {
            contractId: 'CBAID77FC57C6LNDGPS2RTTWA6RZY72LXJYQMLZMX3NBO4VSWGXLTVT2',
            xlmToClpRate: 100, // 1 XLM = 100 CLP
            // XLM nativo en Soroban testnet - dirección correcta del contrato de token XLM
            tokenId: 'CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC',
            network: 'testnet',
            rpcUrl: 'https://soroban-testnet.stellar.org',
            sorobanRpcUrl: 'https://soroban-testnet.stellar.org', // URL específica para RPC crudo
            // Passphrase correcta para testnet
            networkPassphrase: 'Test SDF Network ; September 2015'
        };

        // Variables globales
        let server;
        let userAddress = null;
        let isConnected = false;
        let isFreighterAvailable = false;

        // --- Sistema de Notificaciones Flotantes ---
        let notificationCounter = 0;

        function showNotification(type, title, message, duration = 5000) {
            const container = document.getElementById('notifications-container');
            if (!container) return;

            const id = `notification-${++notificationCounter}`;
            const notification = document.createElement('div');
            notification.id = id;
            notification.className = `notification ${type}`;

            const icons = {
                success: '✓',
                error: '✕',
                warning: '⚠',
                info: 'ℹ'
            };

            const titles = {
                success: 'Éxito',
                error: 'Error',
                warning: 'Advertencia',
                info: 'Información'
            };

            notification.innerHTML = `
                <div class="notification-icon">${icons[type] || 'ℹ'}</div>
                <div class="notification-content">
                    <div class="notification-title">${titles[type] || 'Notificación'}</div>
                    <div class="notification-message">${message}</div>
                </div>
                <button class="notification-close" onclick="hideNotification('${id}')">×</button>
                <div class="notification-progress" style="width: 100%;"></div>
            `;

            container.appendChild(notification);

            // Trigger animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // Auto-hide after duration
            if (duration > 0) {
                const progressBar = notification.querySelector('.notification-progress');
                if (progressBar) {
                    progressBar.style.transition = `width ${duration}ms linear`;
                    progressBar.style.width = '0%';
                }

                setTimeout(() => {
                    hideNotification(id);
                }, duration);
            }

            return id;
        }

        function hideNotification(id) {
            const notification = document.getElementById(id);
            if (!notification) return;

            notification.classList.remove('show');
            notification.classList.add('hide');

            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 400);
        }

        function hideAllNotifications() {
            const container = document.getElementById('notifications-container');
            if (!container) return;

            const notifications = container.querySelectorAll('.notification');
            notifications.forEach(notification => {
                hideNotification(notification.id);
            });
        }

        // --- Funciones de Administración de Pools ---
        function getAdminCode() {
            console.log('🔑 [DEBUG] getAdminCode() iniciada');
            
            let code = localStorage.getItem('pools_admin_code') || '';
            console.log('🔑 [DEBUG] Código desde localStorage:', code ? 'SÍ (longitud: ' + code.length + ')' : 'NO');
            
            if (!code) {
                console.log('🔑 [DEBUG] No hay código guardado, pidiendo al usuario');
                code = prompt('Ingresa el código de administrador para ocultar/mostrar:') || '';
                console.log('🔑 [DEBUG] Código ingresado por usuario:', code ? 'SÍ (longitud: ' + code.length + ')' : 'NO');
                
                if (code) {
                    localStorage.setItem('pools_admin_code', code);
                    console.log('🔑 [DEBUG] Código guardado en localStorage');
                } else {
                    console.log('🔑 [DEBUG] Usuario no ingresó código');
                }
            } else {
                console.log('🔑 [DEBUG] Usando código existente del localStorage');
            }
            
            console.log('🔑 [DEBUG] Código final a retornar:', code ? 'SÍ' : 'NO');
            return code;
        }

        function clearAdminCode() {
            console.log('🗑️ [DEBUG] clearAdminCode() - Limpiando código de admin del localStorage');
            localStorage.removeItem('pools_admin_code');
            console.log('✅ [DEBUG] Código de admin limpiado');
        }

        async function hideAllPools() {
            console.log('🚀 [DEBUG] hideAllPools() iniciada');
            
            const code = getAdminCode();
            console.log('🔑 [DEBUG] Código de admin obtenido:', code ? 'SÍ' : 'NO');
            
            if (!code) {
                console.log('❌ [DEBUG] No hay código de admin, cancelando');
                return showAlert('Acción cancelada: sin código', 'warning');
            }

            try {
                console.log('📡 [DEBUG] Obteniendo lista de pools desde /api/pools?all=1');
                // Traer TODAS las pools (no solo "actionable")
                const res = await fetch('/api/pools?all=1');
                console.log('📡 [DEBUG] Respuesta del servidor:', res.status, res.statusText);
                
                if (!res.ok) {
                    console.log('❌ [DEBUG] Error en respuesta del servidor:', res.status);
                    throw new Error(`HTTP ${res.status}`);
                }

                // ⬅️ DES-ESTRUCTURAR correctamente
                const { pools } = await res.json();
                console.log('📊 [DEBUG] Pools obtenidas:', pools ? pools.length : 'undefined', 'pools');
                console.log('📊 [DEBUG] Detalles de pools:', pools);

                if (!Array.isArray(pools) || pools.length === 0) {
                    console.log('ℹ️ [DEBUG] No hay pools para ocultar');
                    showAlert('No hay cooperativas para ocultar', 'info');
                    return;
                }

                console.log('🔄 [DEBUG] Iniciando proceso de ocultación de', pools.length, 'pools');
                
                let hiddenCount = 0;
                let errorCount = 0;

                for (const p of pools) {
                    console.log(`🔄 [DEBUG] Procesando pool ID=${p.id}`);
                    
                    const r = await fetch('/api/pools/hide', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-admin-code': code,       // envías el código al backend
                        },
                        body: JSON.stringify({ id: p.id })
                    });

                    console.log(`📡 [DEBUG] Respuesta para pool ${p.id}:`, r.status, r.statusText);

                    if (r.status === 403) {
                        console.log('❌ [DEBUG] Código de admin inválido (403)');
                        clearAdminCode();             // borra el que tengas guardado
                        throw new Error('Código de administrador inválido (403)');
                    }

                    if (r.ok) {
                        hiddenCount++;
                        console.log(`✅ [DEBUG] Pool ${p.id} ocultada exitosamente`);
                        
                        // quita la tarjeta si existe en el DOM y limpia caches
                        const el = document.getElementById(`pool-${p.id}`);
                        if (el) {
                            console.log(`🗑️ [DEBUG] Removiendo elemento DOM para pool ${p.id}`);
                            el.remove();
                        } else {
                            console.log(`⚠️ [DEBUG] No se encontró elemento DOM para pool ${p.id}`);
                        }
                        activePoolsCache.delete(String(p.id));
                        console.log(`🗑️ [DEBUG] Removido de activePoolsCache: ${p.id}`);
                    } else {
                        errorCount++;
                        console.log(`❌ [DEBUG] Error ocultando pool ${p.id}:`, r.status);
                    }
                }

                console.log(`📊 [DEBUG] Resumen: ${hiddenCount} ocultadas, ${errorCount} errores`);

                // Limpia snapshot local y refresca el listado
                console.log('🗑️ [DEBUG] Limpiando localStorage...');
                localStorage.removeItem('pools_snapshot');
                console.log('✅ [DEBUG] localStorage limpiado');
                
                console.log('🎉 [DEBUG] Mostrando notificación de éxito');
                showAlert(`✅ ${hiddenCount} cooperativas ocultadas`, 'success');
                
                console.log('🔄 [DEBUG] Refrescando vista...');
                await loadActivePools();
                console.log('✅ [DEBUG] Vista refrescada');

            } catch (e) {
                console.log('❌ [DEBUG] Error general en hideAllPools:', e.message);
                console.log('❌ [DEBUG] Stack trace:', e.stack);
                showAlert('❌ Error al ocultar: ' + e.message, 'danger');
            }
        }

        async function unhidePool(id) {
            const code = getAdminCode();
            if (!code) return showAlert('Acción cancelada: sin código', 'warning');
            try {
                const r = await fetch('/api/pools/unhide', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'x-admin-code': code },
                    body: JSON.stringify({ id })
                });
                if (!r.ok) {
                    if (r.status === 403) { clearAdminCode(); }
                    const err = await r.json().catch(()=>({error:'error'}));
                    throw new Error(err.error || 'Error al mostrar');
                }
                showAlert(`Cooperativa #${id} restaurada`, 'success');
                // Refrescar listado para que reaparezca
                await loadActivePools();
            } catch(e) {
                showAlert(e.message, 'danger');
            }
        }

        // Función de confirmación para eliminar todas las pools
        async function confirmDeleteAllPools() {
            console.log('🔍 [DEBUG] confirmDeleteAllPools() iniciada');
            
            const confirmation = prompt(
                '⚠️ ADVERTENCIA: Esta acción ocultará TODAS las cooperativas del listado público.\n\n' +
                'Las cooperativas seguirán existiendo en la blockchain, pero no serán visibles para los usuarios.\n' +
                'Esta acción es REVERSIBLE - puedes restaurar las cooperativas más tarde.\n\n' +
                'Escribe "ELIMINAR" para confirmar:'
            );
            
            console.log('🔍 [DEBUG] Confirmación del usuario:', confirmation);
            
            if (confirmation === 'ELIMINAR') {
                console.log('✅ [DEBUG] Confirmación válida, procediendo a ocultar todas las pools');
                await hideAllPools();
            } else if (confirmation !== null) {
                console.log('❌ [DEBUG] Confirmación incorrecta:', confirmation);
                showAlert('Acción cancelada: confirmación incorrecta', 'warning');
            } else {
                console.log('🚫 [DEBUG] Usuario canceló la acción');
            }
        }

        // Función para convertir XLM a CLP
        function xlmToClp(xlmAmount) {
            return Math.round(xlmAmount * CONFIG.xlmToClpRate);
        }

        // Función para formatear CLP con separadores de miles
        function formatClp(amount) {
            return new Intl.NumberFormat('es-CL').format(amount);
        }

        // Función para actualizar conversión en tiempo real
        function updateConversion(inputId, conversionId) {
            const input = document.getElementById(inputId);
            const conversion = document.getElementById(conversionId);
            
            if (input && conversion) {
                const xlmValue = parseFloat(input.value) || 0;
                const clpValue = xlmToClp(xlmValue);
                conversion.textContent = `≈ $${formatClp(clpValue)} CLP`;
            }
        }

        // -------- Prefabs --------
        const PREFAB_SUPPLIER = 'GDP3KC3C7TIY3JV4PIYLLWTSI2CWTDP5GIZK65SEX3V56XXA5GSYJR2M';
        const PREFABS = {
            lenia:        { title: 'Leña para invierno',   clp: 1320000, months: 5, icon: 'firewood' },
            gas:          { title: 'Gas 15 kg comunitario', clp: 600000,  months: 1, icon: 'gas' },
            canasta:      { title: 'Canasta básica mensual',clp: 800000,  months: 1, icon: 'basket' },
            fertilizante: { title: 'Fertilizante siembra',  clp: 2500000, months: 3, icon: 'fertilizer' },
            semillas:     { title: 'Semillas de temporada', clp: 450000,  months: 2, icon: 'seeds' },
            herramientas: { title: 'Herramientas agrícolas', clp: 1800000, months: 6, icon: 'tools' },
            medicinas:    { title: 'Medicinas veterinarias', clp: 320000,  months: 1, icon: 'medicine' },
            electricidad: { title: 'Pago de electricidad',  clp: 750000,  months: 1, icon: 'electricity' }
        };

// --- Cache de pools activos para el dropdown ---
const activePoolsCache = new Map();

// --- Watcher de deadlines para refresco automático ---
const poolDeadlineTimers = new Map();

// Poller de seguridad para refrescar pools activos cada 2 minutos
setInterval(async () => {
    try {
        // Poller de seguridad
        for (const pool of activePoolsCache.values()) {
            await getPoolInfo(Number(pool.id));
        }
    } catch (e) {
        // Poller falló
    }
}, 120000); // 2 minutos

        // Asegura balance suficiente en el contrato de token (SAC) para contribuir
        async function ensureWrappedXlm(amountStroops, tokenId = CONFIG.tokenId) {
            const account = await server.getAccount(userAddress);
            const userAddr = StellarSdk.Address.fromString(userAddress);

            // 1) Consultar balance del token (read-only por simulación)
            const balanceOp = StellarSdk.Operation.invokeContractFunction({
                contract: tokenId,
                function: 'balance',
                args: [StellarSdk.nativeToScVal(userAddr, { type: 'address' })]
            });
            let balTx = new StellarSdk.TransactionBuilder(account, {
                fee: StellarSdk.BASE_FEE, 
                networkPassphrase: CONFIG.networkPassphrase
            }).addOperation(balanceOp).setTimeout(60).build();

            const balSim = await server.simulateTransaction(balTx);
            if (balSim.error) throw new Error('No se pudo simular balance: ' + balSim.error);
            const current = BigInt(StellarSdk.scValToNative(
                balSim.result?.retval ?? balSim.result?.returnValue ?? balSim.returnValue
            ));

            // 2) Si falta, depositar diferencia
            if (current < amountStroops) {
                const diff = amountStroops - current;

                // IMPORTANTE: necesitarás saldo XLM clásico suficiente (reserva base + fees)
                const depositOp = StellarSdk.Operation.invokeContractFunction({
                    contract: tokenId,
                    function: 'deposit',
                    args: [
                        StellarSdk.nativeToScVal(userAddr, { type: 'address' }),
                        StellarSdk.nativeToScVal(diff, { type: 'i128' })
                    ]
                });

                let depTx = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE, 
                    networkPassphrase: CONFIG.networkPassphrase
                }).addOperation(depositOp).setTimeout(600).build();

                const depSim = await server.simulateTransaction(depTx);
                if (depSim.error) throw new Error('Error en simulación de deposit: ' + depSim.error);

                depTx = await server.prepareTransaction(depTx);
                const depSigned = await window.freighter.signTransaction(depTx.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase, 
                    address: userAddress
                });
                if (depSigned.error) throw new Error(depSigned.error);
                
                const depXdr = depSigned.signedTxXdr ?? depSigned.signedXDR;
                const depSubmit = await server.sendTransaction(
                    StellarSdk.TransactionBuilder.fromXDR(depXdr, CONFIG.networkPassphrase)
                );

                // Espera confirmación si viene PENDING
                if (depSubmit.status === 'PENDING') {
                    const final = await waitForTx(depSubmit.hash);
                    if (final.status !== 'SUCCESS') {
                        throw new Error('Deposit falló on-chain: ' + final.status);
                    }
                } else if (depSubmit.status !== 'SUCCESS') {
                    throw new Error('Deposit no aceptado: ' + depSubmit.status);
                }
            }
        }

        function isPoolActive(pool) {
            const now = Math.floor(Date.now()/1000);
            return pool && !pool.finalized && Number(pool.deadline) > now;
        }

        function rememberActivePool(pool) {
            if (!pool) return;
            if (isPoolActive(pool)) {
                activePoolsCache.set(String(pool.id), pool);
            } else {
                activePoolsCache.delete(String(pool.id));
            }
        }

function refreshContribDropdownFromCache({ preserve = true } = {}) {
    const sel = document.getElementById('contrib-pool-select');
    if (!sel) return;

    // Guarda el valor actual (si queremos preservar)
    const prevValue = preserve ? sel.value : '';
    const hasPrev   = prevValue && activePoolsCache.has(String(prevValue));

    // Reconstruye opciones
    sel.innerHTML = '';
    const size = activePoolsCache.size;

    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = size ? 'Selecciona una cooperativa…' : 'No hay cooperativas activas';
    // El placeholder solo queda "selected" si NO teníamos selección válida
    placeholder.selected = !hasPrev;
    sel.appendChild(placeholder);

    const truncate = (s, max=28) => (s && s.length > max) ? s.slice(0, max-1) + '…' : (s || '');

    [...activePoolsCache.values()]
        .sort((a,b) => Number(a.id) - Number(b.id))
        .forEach(pool => {
            const option = document.createElement('option');
            const goalXlm   = Number(pool.goal)   / 1e7;
            const raisedXlm = Number(pool.raised) / 1e7;
            const pct = goalXlm > 0 ? Math.floor((raisedXlm/goalXlm)*100) : 0;
            const d = new Date(Number(pool.deadline) * 1000);
            const name = pool.name ? truncate(pool.name, 28) : `#${pool.id}`;
            option.value = String(pool.id);
            option.textContent = `${name} — ${pct}% — meta ${goalXlm} XLM — vence ${d.toLocaleDateString('es-CL')}`;
            sel.appendChild(option);
        });

    // Vuelve a aplicar la selección si seguía siendo válida
    if (hasPrev) sel.value = prevValue;

    // Habilita/deshabilita el control
    sel.disabled = size === 0;
}

// Máximo seguro para setTimeout (2^31-1 ms) con margen
const MAX_TIMEOUT_MS = 2_147_000_000;

// Espera en tramos hasta completar "ms"
// onDone se ejecuta al final
function waitLong(ms, onDone) {
  if (ms <= MAX_TIMEOUT_MS) {
    return setTimeout(onDone, ms);
  }
  // programa un tramo y recursivo
  return setTimeout(() => {
    waitLong(ms - MAX_TIMEOUT_MS, onDone);
  }, MAX_TIMEOUT_MS);
}

// Programa un refresco automático al llegar el deadline
function scheduleDeadlineWatcher(poolId, deadlineSec) {
    try {
        // Limpia timer anterior si existía
        const prev = poolDeadlineTimers.get(poolId);
        if (prev) clearTimeout(prev);

        const msUntilDeadline = (Number(deadlineSec) * 1000) - Date.now();
        // si ya pasó, refrescar pronto
        const delay = msUntilDeadline <= 0 ? 500 : (msUntilDeadline + 1500);

        const handle = waitLong(delay, async () => {
            try {
                // Deadline alcanzado
                await getPoolInfo(poolId);
            } catch (e) {
                // Error al refrescar pool
            }
        });

        poolDeadlineTimers.set(poolId, handle);
        // Programado refresco para pool
    } catch (e) {
        // No se pudo programar watcher
    }
}

// Limpia un watcher específico (útil al finalizar/reembolsar)
function clearDeadlineWatcher(poolId) {
    const t = poolDeadlineTimers.get(poolId);
    if (t) {
        clearTimeout(t);
        poolDeadlineTimers.delete(poolId);
        // Timer limpiado
    }
}

// Limpia todos los timers de deadline (útil al desconectar)
function clearAllDeadlineTimers() {
    // Limpiando watchers
    for (const [poolId, timer] of poolDeadlineTimers.entries()) {
        clearTimeout(timer);
        // Timer limpiado
    }
    poolDeadlineTimers.clear();
}

        // Valida si un pool puede ser reembolsado según las reglas del contrato
        function canRefund(pool) {
            const now = Math.floor(Date.now()/1000);
            return (
                pool &&
                !pool.finalized &&
                now > Number(pool.deadline) &&
                BigInt(pool.raised) < BigInt(pool.goal)
            );
        }

        // Formatea Date a 'YYYY-MM-DDTHH:MM' en HORA LOCAL para <input type="datetime-local">
        function formatLocalDatetime(d) {
            const pad = n => String(n).padStart(2, '0');
            return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
        }

        function addMonthsFromNowLocal(months) {
            const d = new Date();
            d.setMonth(d.getMonth() + months);
            return formatLocalDatetime(d);
        }

        // Aplica la plantilla y dispara createPool()
        async function createPrefab(key) {
            if (!isConnected || !userAddress) {
                showAlert('❌ Conecta tu billetera para crear una cooperativa', 'danger');
                return;
            }

            const p = PREFABS[key];
            if (!p) { 
                showAlert('❌ Plantilla no encontrada', 'danger'); 
                return; 
            }

            // CLP → XLM (redondeo hacia arriba)
            const xlm = Math.ceil(p.clp / CONFIG.xlmToClpRate);

            // Prellenar formulario principal
            const supEl = document.getElementById('supplier');
            const goalEl = document.getElementById('goal');
            const dlEl   = document.getElementById('deadline');

            if (supEl) supEl.value = PREFAB_SUPPLIER;
            if (goalEl) goalEl.value = String(xlm);
            if (dlEl)   dlEl.value   = addMonthsFromNowLocal(p.months);

            // Actualiza el texto de conversión bajo la meta
            updateConversion('goal', 'goal-conversion');

            // Confirmación UX
            const ok = confirm(`¿Crear cooperativa "${p.title}"?\n\n` +
                             `Proveedor: ${PREFAB_SUPPLIER}\n` +
                             `Meta: ${xlm} XLM (≈ $${formatClp(p.clp)} CLP)\n` +
                             `Vence en: ${p.months} mes(es)`);
            if (!ok) return;

            // Ejecuta el flujo normal (simula → firma → envía → espera)
            await createPool();
        }

        // Variables del carrusel
        let currentSlide = 0;
        const cardsPerSlide = 3;

        // Iconos SVG para las plantillas
        const SVG_ICONS = {
            firewood: `<svg class="prefab-icon" width="64" height="48" viewBox="0 0 64 48" xmlns="http://www.w3.org/2000/svg" role="img" aria-labelledby="title-wood-bundle">
                <title id="title-wood-bundle">Leña para invierno</title>
                <style>
                    :root{
                        --bark:#8B5E3C;   /* corteza */
                        --wood:#D8A565;   /* interior del corte */
                        --grain:#6B442B;  /* vetas */
                        --strap:#3F7A3C;  /* cinta/amarre (verde cooperativa) */
                        --edge:#5a3821;   /* borde sutil */
                    }
                </style>
                <!-- Tronco izquierdo -->
                <rect x="12" y="10" width="14" height="28" rx="6" fill="var(--bark)" />
                <circle cx="19" cy="12" r="6" fill="var(--wood)" />
                <path d="M19 9.2a3 3 0 1 1 0 5.6m0-3.7a1.6 1.6 0 1 1 0 3.2"
                      stroke="var(--grain)" stroke-width="1.2" fill="none" />
                <!-- Tronco central (ligeramente más alto) -->
                <rect x="26" y="8" width="14" height="32" rx="6" fill="var(--bark)" />
                <circle cx="33" cy="10" r="6" fill="var(--wood)" />
                <path d="M33 7.2a3 3 0 1 1 0 5.6m0-3.7a1.6 1.6 0 1 1 0 3.2"
                      stroke="var(--grain)" stroke-width="1.2" fill="none" />
                <!-- Tronco derecho -->
                <rect x="40" y="10" width="14" height="28" rx="6" fill="var(--bark)" />
                <circle cx="47" cy="12" r="6" fill="var(--wood)" />
                <path d="M47 9.2a3 3 0 1 1 0 5.6m0-3.7a1.6 1.6 0 1 1 0 3.2"
                      stroke="var(--grain)" stroke-width="1.2" fill="none" />
                <!-- Cinta que amarra el haz -->
                <rect x="10" y="22" width="44" height="6" rx="3" fill="var(--strap)"/>
                <!-- Pequeña sombra/borde para mayor lectura -->
                <rect x="10" y="22" width="44" height="6" rx="3" fill="none" stroke="var(--edge)" stroke-opacity=".15"/>
                <!-- Base sutil para asentar el icono -->
                <ellipse cx="32" cy="41" rx="22" ry="3" fill="rgba(0,0,0,.06)"/>
            </svg>`,
            gas: `<svg class="prefab-icon" width="48" height="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" role="img" aria-labelledby="title-gas-yellow">
                <title id="title-gas-yellow">Gas 15 kg comunitario</title>
                <style>
                    :root{
                        --body:#F9C52C;   /* cuerpo amarillo */
                        --cap:#D99A00;    /* tapa/detalles más oscuros */
                        --edge:#7A5B00;   /* borde para contraste */
                        --stripe:#FFF3C2; /* franja central clara */
                    }
                </style>
                <!-- tapa -->
                <rect x="8" y="2" width="8" height="3" rx="1" fill="var(--cap)"/>
                <!-- cuerpo -->
                <rect x="5" y="5" width="14" height="14" rx="3" fill="var(--body)"/>
                <!-- franja central -->
                <rect x="5" y="11" width="14" height="2" fill="var(--stripe)"/>
                <!-- borde/contorno -->
                <rect x="5" y="5" width="14" height="14" rx="3" fill="none" stroke="var(--edge)" stroke-width="1.4"/>
                <!-- pequeña válvula (detalle) -->
                <rect x="10" y="4" width="4" height="1.6" rx="0.6" fill="var(--cap)"/>
            </svg>`,
            basket: `<svg class="prefab-icon" width="48" height="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" role="img" aria-labelledby="title-basket">
                <title id="title-basket">Canasta básica mensual</title>
                <style>
                    :root {
                        --basket:#C58F50;  /* color mimbre */
                        --handle:#8B5E3C;  /* asa más oscura */
                        --lines:#6B442B;   /* rejilla */
                    }
                </style>
                <!-- asa -->
                <path d="M7 9c0-2.8 2.2-5 5-5s5 2.2 5 5" stroke="var(--handle)" stroke-width="2" fill="none"/>
                <!-- cuerpo -->
                <rect x="3" y="9" width="18" height="10" rx="2.2" fill="var(--basket)" stroke="var(--handle)" stroke-width="1.8"/>
                <!-- rejilla -->
                <path d="M7 12v4M12 12v4M17 12v4M4.5 14h15" stroke="var(--lines)" stroke-width="1.5"/>
            </svg>`,
            fertilizer: `<svg class="prefab-icon" width="48" height="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-labelledby="title-fertilizer" role="img">
                <title id="title-fertilizer">Fertilizante de siembra</title>
                <style>
                    :root{
                        --bag:#C58F50;
                        --edge:#8B5E3C;
                        --leaf:#2E7D32;
                    }
                </style>
                <!-- saco -->
                <rect x="6" y="5" width="12" height="14" rx="2" fill="var(--bag)" stroke="var(--edge)" stroke-width="1.6"/>
                <!-- borde superior -->
                <rect x="5.5" y="4" width="13" height="2" rx="1" fill="var(--edge)"/>
                <!-- brote -->
                <path d="M12 11c-1.5 0-2.5 1.2-2.5 2.5 0 1.4 1.1 2.5 2.5 2.5s2.5-1.1 2.5-2.5C14.5 12.2 13.5 11 12 11z" fill="var(--leaf)"/>
                <path d="M12 11v5" stroke="var(--leaf)" stroke-width="1.4" stroke-linecap="round"/>
            </svg>`,
            seeds: `<svg class="prefab-icon" width="48" height="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-labelledby="title-seeds" role="img">
                <title id="title-seeds">Semillas de temporada</title>
                <style>
                    :root{
                        --seed:#A1723D;
                        --grain:#5A3821;
                    }
                </style>
                <!-- tres semillas -->
                <ellipse cx="9" cy="10" rx="2" ry="3" fill="var(--seed)" stroke="var(--grain)" stroke-width="1"/>
                <ellipse cx="14" cy="13" rx="2" ry="3" fill="var(--seed)" stroke="var(--grain)" stroke-width="1"/>
                <ellipse cx="11" cy="17" rx="2" ry="3" fill="var(--seed)" stroke="var(--grain)" stroke-width="1"/>
                <!-- líneas de caída -->
                <path d="M9 7c-.3-1-.6-2-1-3" stroke="var(--grain)" stroke-width="1" stroke-linecap="round"/>
                <path d="M14 10c.4-1 .7-2 1-3" stroke="var(--grain)" stroke-width="1" stroke-linecap="round"/>
            </svg>`,
            tools: `<svg class="prefab-icon" viewBox="0 0 24 24" fill="none" stroke="#8b4513" stroke-width="2">
                <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-3.77 3.77a1 1 0 0 1-1.4 0l-1.6-1.6a1 1 0 0 1 0-1.4l3.77-3.77a6 6 0 0 1 7.94-7.94l3.77 3.77z"/>
            </svg>`,
            medicine: `<svg class="prefab-icon" viewBox="0 0 24 24" fill="none" stroke="#8b4513" stroke-width="2">
                <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.29 1.51 4.04 3 5.5l7 7z"/>
                <path d="M12 5l-1 1-2-2"/>
                <path d="M12 5l1 1 2-2"/>
            </svg>`,
            electricity: `<svg class="prefab-icon" viewBox="0 0 24 24" fill="none" stroke="#8b4513" stroke-width="2">
                <polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"/>
            </svg>`
        };

        // Generar las tarjetas del carrusel
        function generateCarouselCards() {
            const track = document.getElementById('carousel-track');
            const dots = document.getElementById('carousel-dots');
            
            if (!track || !dots) return;

            // Limpiar contenido existente
            track.innerHTML = '';
            dots.innerHTML = '';

            // Generar tarjetas
            Object.entries(PREFABS).forEach(([key, prefab]) => {
                const xlm = Math.ceil(prefab.clp / CONFIG.xlmToClpRate);
                const card = document.createElement('div');
                card.className = 'carousel-card';
                card.innerHTML = `
                    <div>
                        ${SVG_ICONS[prefab.icon] || ''}
                        <h4 style="margin: 10px 0; color: #2d5016;">${prefab.title}</h4>
                        <div class="info-item">
                            <div class="info-label">Presupuesto</div>
                            <div class="info-value">$${formatClp(prefab.clp)} CLP (≈ ${xlm} XLM)</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Vence</div>
                            <div class="info-value">${prefab.months} mes(es) desde hoy</div>
                        </div>
                    </div>
                    <button class="btn btn-success" onclick="createPrefab('${key}')" style="margin-top: auto;">
                        🌱 Crear cooperativa
                    </button>
                `;
                track.appendChild(card);
            });

            // Generar puntos de navegación
            const totalSlides = Math.ceil(Object.keys(PREFABS).length / cardsPerSlide);
            for (let i = 0; i < totalSlides; i++) {
                const dot = document.createElement('div');
                dot.className = `carousel-dot ${i === 0 ? 'active' : ''}`;
                dot.onclick = () => goToSlide(i);
                dots.appendChild(dot);
            }

            updateCarousel();
        }

        // Mover carrusel
        function moveCarousel(direction) {
            const totalSlides = Math.ceil(Object.keys(PREFABS).length / cardsPerSlide);
            currentSlide += direction;
            
            if (currentSlide < 0) {
                currentSlide = totalSlides - 1;
            } else if (currentSlide >= totalSlides) {
                currentSlide = 0;
            }
            
            updateCarousel();
        }

        // Ir a slide específico
        function goToSlide(slideIndex) {
            currentSlide = slideIndex;
            updateCarousel();
        }

        // Actualizar carrusel
        function updateCarousel() {
            const track = document.getElementById('carousel-track');
            const dots = document.querySelectorAll('.carousel-dot');
            
            if (!track) return;

            const translateX = -currentSlide * (100 / cardsPerSlide);
            track.style.transform = `translateX(${translateX}%)`;

            // Actualizar puntos activos
            dots.forEach((dot, index) => {
                dot.classList.toggle('active', index === currentSlide);
            });
        }

        // Elementos DOM
        const statusIndicator = () => document.getElementById('status-indicator');
        const connectBtn = () => document.getElementById('connect-btn');
        const disconnectBtn = () => document.getElementById('disconnect-btn');
        const walletInfo = () => document.getElementById('wallet-info');
        const walletAddressPanel = () => document.getElementById('wallet-address-panel');
        const userAddressSpan = () => document.getElementById('user-address');
        const networkNameSpan = () => document.getElementById('network-name');
        const connectionStatusSpan = () => document.getElementById('connection-status');
        
        // Referencias para el nuevo panel de dirección
        const fullAddressSpan = () => document.getElementById('full-address');
        const shortAddressSpan = () => document.getElementById('short-address');
        const networkBadgeSpan = () => document.getElementById('network-badge');
        const connectionTextSpan = () => document.getElementById('connection-text');

        // Inicializar aplicación
        async function init() {
            // Inicializando dApp
            server = new StellarSdk.SorobanRpc.Server(CONFIG.rpcUrl);
            
            // Cargar hash de transacción desde localStorage
            loadLastTransaction();
            
            // Habilitar botón de cargar pools (no requiere wallet)
            enableLoadPoolsButton();
            
            // Pintar snapshot rápido mientras llega la red (deshabilitado para evitar datos viejos)
            const SHOW_SNAPSHOT = false; // deshabilitado para evitar flickers durante testing
            if (SHOW_SNAPSHOT) {
                try {
                    const raw = localStorage.getItem('pools_snapshot');
                    if (raw) {
                        const cached = JSON.parse(raw);
                        const container = document.getElementById('pools-list');
                        if (container) container.innerHTML = '';
                        for (const pool of cached) {
                            renderPoolCard(Number(pool.id), pool, pool.status);
                            rememberActivePool(pool);
                            scheduleDeadlineWatcher(pool.id, pool.deadline);
                        }
                        refreshContribDropdownFromCache();
                    }
                } catch(_) {}
            }

            // 🔸 Auto-sana el backend desde el snapshot local
            try { await selfHealBackendFromSnapshot(); } catch(e) { /* No se pudo auto-sanar el backend */ }
            
            // Esperar a que se carguen los scripts y verificar disponibilidad
            let retries = 0;
            const maxRetries = 10;
            
            while (retries < maxRetries) {
                if (typeof StellarSdk !== 'undefined') {
                    // Stellar SDK cargado
                    break;
                }
                await new Promise(resolve => setTimeout(resolve, 500));
                retries++;
            }
            
            if (retries >= maxRetries) {
                showAlert('❌ Error: No se pudo cargar Stellar SDK', 'danger');
                return;
            }
            
            // Mostrar estado inicial mientras verificamos Freighter
            statusIndicator().textContent = '🔄 Verificando Freighter...';
            statusIndicator().className = 'status-indicator status-loading';
            
            // Verificar Freighter (esto incluye su propio updateUI al final)
            await checkFreighterAvailability();
            
            // 🔸 Cargar automáticamente las pools públicas al abrir la dApp (después de detectar Freighter)
            try { await loadActivePools(); } catch(e) { /* No se pudieron cargar pools al iniciar */ }
        }

        // Verificar disponibilidad de Freighter usando la API oficial importada
        async function checkFreighterAvailability() {
            // Verificando Freighter
            
            // Esperar a que el módulo ES6 se cargue
            const waitForFreighterAPI = () => {
                return new Promise((resolve) => {
                    // Si ya está disponible
                    if (window.freighterApi) {
                        // Log removed
                        resolve(true);
                        return;
                    }
                    
                    // Escuchar evento de carga del módulo
                    const handleFreighterReady = () => {
                        // Log removed
                        window.removeEventListener('freighter-ready', handleFreighterReady);
                        resolve(true);
                    };
                    
                    window.addEventListener('freighter-ready', handleFreighterReady);
                    
                    // Timeout después de 5 segundos
                    setTimeout(() => {
                        window.removeEventListener('freighter-ready', handleFreighterReady);
                        // Log removed
                        resolve(false);
                    }, 5000);
                });
            };
            
            const apiLoaded = await waitForFreighterAPI();
            
            if (apiLoaded && window.freighterApi) {
                // Log removed
                
                // Normalizar API
                window.freighter = window.freighterApi;
                
                await handleFreighterDetected();
                return;
            }
            
            // Si no se cargó la API, mostrar error específico
            // Log removed
            // Log removed
            console.log('   - Problema de red (CDN no disponible)');
            // Log removed
            // Log removed
            // Log removed
            
            handleFreighterNotFound();
        }

        // Manejar Freighter detectado
        async function handleFreighterDetected() {
            try {
                isFreighterAvailable = true;
                // Log removed
                
                // Verificar métodos disponibles
                
                // Verificar si hay una conexión existente
                let isConnectedResult = false;
                try {
                    isConnectedResult = await window.freighter.isConnected();
                } catch (e) {
                    // Log removed
                }
                
                if (isConnectedResult) {
                    try {
                        // Intentar obtener la clave pública de diferentes maneras
                        let publicKey = null;
                        
                        try {
                            // Intentar getAddress() primero (más ligero)
                            const addressResult = await window.freighter.getAddress();
                            
                            if (addressResult && !addressResult.error && addressResult.address) {
                                userAddress = addressResult.address;
                                isConnected = true;
                                showAlert('✅ Freighter conectado automáticamente', 'success');
                                await updateNetworkInfo();
                            } else {
                                // Si getAddress() no funciona, intentar requestAccess()
                                const accessResult = await window.freighter.requestAccess();
                                
                                if (accessResult && !accessResult.error && accessResult.address) {
                                    userAddress = accessResult.address;
                                    isConnected = true;
                                    showAlert('✅ Freighter conectado automáticamente', 'success');
                                    await updateNetworkInfo();
                                } else {
                                    showAlert('💡 Freighter detectado. Haz clic en "Conectar" para continuar.', 'info');
                                }
                            }
                        } catch (e) {
                            // Log removed
                            showAlert('💡 Freighter detectado. Haz clic en "Conectar" para continuar.', 'info');
                        }
                    } catch (pkError) {
                        // Log removed
                        showAlert('💡 Freighter detectado. Haz clic en "Conectar" para continuar.', 'info');
                    }
                } else {
                    showAlert('💡 Freighter detectado. Haz clic en "Conectar" para continuar.', 'info');
                }
            } catch (error) {
                // Log removed
                showAlert('⚠️ Freighter detectado pero con errores: ' + error.message, 'danger');
                // Aún así, marcar como disponible para permitir intentos de conexión
                isFreighterAvailable = true;
            } finally {
                updateUI();
            }
        }

        // Manejar Freighter no encontrado
        function handleFreighterNotFound() {
            isFreighterAvailable = false;
            
            // Mostrar mensaje específico para el problema de inyección
            const isChrome = navigator.userAgent.includes('Chrome');
            let message = '❌ Freighter no se está inyectando correctamente.';
            
            if (isChrome) {
                message += '\n\n🔧 Soluciones para Chrome:';
                message += '\n1. Verifica que Freighter esté habilitado en chrome://extensions/';
                message += '\n2. Asegúrate de que "Permitir en modo incógnito" esté activado si usas incógnito';
                message += '\n3. Recarga la extensión (toggle off/on)';
                message += '\n4. Reinicia Chrome completamente';
                message += '\n5. Si el problema persiste, reinstala Freighter';
            }
            
            showAlert(message, 'danger');
            
            // Mostrar botones de acción
            document.getElementById('retry-btn').style.display = 'inline-block';
            
            const connectButton = connectBtn();
            connectButton.textContent = isChrome ? 'Abrir Extensiones Chrome' : 'Instalar Freighter';
            connectButton.disabled = false;
            connectButton.onclick = () => {
                if (isChrome) {
                    // Abrir página de extensiones de Chrome
                    window.open('chrome://extensions/', '_blank');
                    showAlert('ℹ️ Verifica que Freighter esté habilitado, luego usa "Reintentar Detección".', 'info');
                } else {
                    window.open('https://freighter.app/', '_blank');
                    showAlert('ℹ️ Después de instalar Freighter, usa "Reintentar Detección".', 'info');
                }
            };
            
            updateUI();
        }

        // Función para reintentar la detección de Freighter
        async function retryFreighterDetection() {
            showAlert('🔄 Reintentando detección de Freighter...', 'info');
            
            // Resetear estado
            document.getElementById('retry-btn').style.display = 'none';
            statusIndicator().textContent = '🔄 Verificando Freighter...';
            statusIndicator().className = 'status-indicator status-loading';
            
            // Reintentar detección
            await checkFreighterAvailability();
        }

        // Conectar wallet usando la API oficial correcta
        async function connectWallet() {
            if (!isFreighterAvailable) {
                showAlert('❌ Freighter no está disponible', 'danger');
                return;
            }

            try {
                statusIndicator().textContent = '🔄 Conectando...';
                statusIndicator().className = 'status-indicator status-loading';
                connectBtn().disabled = true;

                // Log removed
                
                // Usar requestAccess() según la documentación oficial
                // requestAccess() -> Promise<{ address: string } & { error?: string }>
                console.log('🔑 Llamando a requestAccess()...');
                const accessResult = await window.freighter.requestAccess();
                console.log('🔑 requestAccess() resultado:', accessResult);
                
                // Verificar si hay error
                if (accessResult.error) {
                    throw new Error(accessResult.error);
                }
                
                // Obtener la dirección del resultado
                if (!accessResult.address || typeof accessResult.address !== 'string') {
                    throw new Error('No se recibió una dirección válida de Freighter');
                }
                
                // Guardar la dirección
                userAddress = accessResult.address;
                isConnected = true;
                
                // Log removed
                // Log removed
                
                // Actualizar información de red
                await updateNetworkInfo();
                
                // Mostrar éxito
                showAlert('✅ Wallet conectada exitosamente', 'success');
                
            } catch (error) {
                // Log removed
                showAlert('❌ Error al conectar: ' + error.message, 'danger');
                isConnected = false;
                userAddress = null;
            } finally {
                connectBtn().disabled = false;
                updateUI();
            }
        }

        // Desconectar wallet
        function disconnectWallet() {
            // Log removed
            isConnected = false;
            userAddress = null;
            showAlert('ℹ️ Wallet desconectada', 'info');

            const connectButton = connectBtn();
            if (connectButton) {
                connectButton.disabled = false;
                connectButton.textContent = '🌾 Conectar';
            }

            // Limpiar watchers de deadline al desconectar
            clearAllDeadlineTimers();

            updateUI(); // ← con las protecciones nuevas ya no revienta
        }

        // Actualizar información de red usando la API oficial
        async function updateNetworkInfo() {
            if (!isConnected || !userAddress) return;

            try {
                // Log removed
                const nd = await window.freighter.getNetworkDetails();
                console.log('🌐 getNetworkDetails() resultado:', nd);
                if (nd.error) throw new Error(nd.error);

                const networkName = nd.network || 'Testnet (por defecto)';

                // 👇 Solo actualiza si existen:
                const networkNameEl  = document.getElementById('network-name');
                const networkBadgeEl = document.getElementById('network-badge');
                if (networkNameEl)  networkNameEl.textContent  = networkName;
                if (networkBadgeEl) networkBadgeEl.textContent = networkName;

                // Log removed
                // Log removed
                // Log removed
            } catch (err) {
                // Log removed

                // Valores por defecto, pero solo si existen
                const networkNameEl  = document.getElementById('network-name');
                const networkBadgeEl = document.getElementById('network-badge');
                if (networkNameEl)  networkNameEl.textContent  = 'Testnet (por defecto)';
                if (networkBadgeEl) networkBadgeEl.textContent = 'Testnet (por defecto)';
            }
        }

        // Obtener información detallada de la red
        async function getNetworkInfo() {
            if (!isConnected) {
                showAlert('❌ Conecta la wallet primero', 'danger');
                return;
            }

            try {
                // Log removed
                
                // Usar getNetworkDetails() según la documentación oficial
                const networkDetails = await window.freighter.getNetworkDetails();
                console.log('🌐 getNetworkDetails() resultado:', networkDetails);
                
                if (networkDetails.error) {
                    throw new Error(networkDetails.error);
                }

                const info = `
                    Red: ${networkDetails.network}
                    URL: ${networkDetails.networkUrl}
                    Passphrase: ${networkDetails.networkPassphrase}
                    ${networkDetails.sorobanRpcUrl ? 'Soroban RPC: ' + networkDetails.sorobanRpcUrl : ''}
                `;
                
                // Log removed
                showAlert('📡 Información de red:\n' + info, 'info');
                
            } catch (error) {
                // Log removed
                
                // Usar valores por defecto en caso de error
                let info = `Red: Testnet (por defecto)\n`;
                info += `Passphrase: ${CONFIG.networkPassphrase}\n`;
                info += `Soroban RPC: ${CONFIG.rpcUrl}`;
                showAlert('📡 Información de red:\n' + info, 'info');
            }
        }

        // Firmar mensaje de prueba usando la API oficial
        async function signTestMessage() {
            if (!isConnected || !userAddress) {
                showAlert('❌ Conecta la wallet primero', 'danger');
                return;
            }

            try {
                // Log removed
                
                const message = 'Compra Colectiva - Mensaje de prueba desde la dApp';
                // Log removed
                
                // Usar signMessage() según la documentación oficial
                // signMessage(message: string, opts: { address: string }) -> Promise<{ signedMessage: string | null; signerAddress: string; } & { error?: string; }>
                const signResult = await window.freighter.signMessage(message, {
                    address: userAddress
                });
                
                console.log('✍️ signMessage() resultado:', signResult);
                
                if (signResult.error) {
                    throw new Error(signResult.error);
                }
                
                if (!signResult.signedMessage) {
                    throw new Error('No se recibió un mensaje firmado');
                }

                // Log removed
                // Log removed
                // Log removed
                
                showAlert('✅ Mensaje firmado correctamente', 'success');
                
            } catch (error) {
                // Log removed
                showAlert('❌ Error firmando: ' + error.message, 'danger');
            }
        }

        // Función para copiar la dirección al portapapeles
        async function copyAddress() {
            if (!userAddress) {
                showAlert('❌ No hay dirección para copiar', 'danger');
                return;
            }

            try {
                await navigator.clipboard.writeText(userAddress);
                showAlert('✅ Dirección copiada al portapapeles', 'success');
                
                // Cambiar temporalmente el ícono del elemento clickeable
                const addressDisplay = document.getElementById('wallet-address-display');
                if (addressDisplay) {
                    const originalText = addressDisplay.textContent;
                    addressDisplay.textContent = '✅ Copiado!';
                    addressDisplay.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
                    
                    setTimeout(() => {
                        addressDisplay.textContent = originalText;
                        addressDisplay.style.background = 'linear-gradient(135deg, #2d5016 0%, #4a7c59 100%)';
                    }, 2000);
                }
                
            } catch (error) {
                // Log removed
                showAlert('❌ Error al copiar la dirección', 'danger');
            }
        }

        // Actualizar interfaz de usuario
        function updateUI() {
            // Log removed
            
            const indicator = statusIndicator();
            const connectButton = connectBtn();
            const disconnectButton = disconnectBtn();
            
            // ⚠️ Estos pueden no existir en tu layout actual:
            const walletInfoDiv = document.getElementById('wallet-info');
            const walletAddressPanelDiv = document.getElementById('wallet-address-panel');
            const userAddrSpan = document.getElementById('user-address');
            const connStatusSpan = document.getElementById('connection-status');
            
            const walletConnectState = document.getElementById('wallet-connect-state');
            const walletConnectedState = document.getElementById('wallet-connected-state');
            const walletLoadingState = document.getElementById('wallet-loading-state');
            const walletAddressShort = document.getElementById('wallet-address-short');

            if (isConnected && userAddress) {
                indicator.textContent = '✅ Conectado';
                indicator.className = 'status-indicator status-connected';

                if (walletLoadingState) walletLoadingState.style.display = 'none';
                if (walletConnectState) walletConnectState.style.display = 'none';
                if (walletConnectedState) walletConnectedState.style.display = 'flex';

                if (walletAddressShort && typeof userAddress === 'string') {
                    walletAddressShort.textContent = `${userAddress.slice(0,8)}...${userAddress.slice(-8)}`;
                }

                if (connectButton) connectButton.style.display = 'none';
                if (disconnectButton) disconnectButton.style.display = 'inline-block';

                // 👇 Solo si existen en el DOM:
                if (walletAddressPanelDiv) walletAddressPanelDiv.style.display = 'block';
                if (walletInfoDiv) walletInfoDiv.style.display = 'none';
                if (userAddrSpan) userAddrSpan.textContent = `${userAddress.slice(0,8)}...${userAddress.slice(-8)}`;
                if (connStatusSpan) connStatusSpan.textContent = 'Conectado';

                enableActionButtons();
                
            } else if (isFreighterAvailable) {
                indicator.textContent = '❌ Desconectado';
                indicator.className = 'status-indicator status-disconnected';

                if (walletLoadingState) walletLoadingState.style.display = 'none';
                if (walletConnectedState) walletConnectedState.style.display = 'none';
                if (walletConnectState) walletConnectState.style.display = 'flex';

                if (connectButton) {
                    connectButton.style.display = 'inline-block';
                    connectButton.disabled = false;
                    connectButton.textContent = '🌾 Conectar';
                }
                if (disconnectButton) disconnectButton.style.display = 'none';

                if (walletAddressPanelDiv) walletAddressPanelDiv.style.display = 'none';
                if (walletInfoDiv) walletInfoDiv.style.display = 'none';
                if (userAddrSpan) userAddrSpan.textContent = 'No disponible';
                if (connStatusSpan) connStatusSpan.textContent = 'Desconectado';

                disableActionButtons();
                
            } else {
                indicator.textContent = '🔄 Verificando...';
                indicator.className = 'status-indicator status-loading';

                if (walletConnectState) walletConnectState.style.display = 'none';
                if (walletConnectedState) walletConnectedState.style.display = 'none';
                if (walletLoadingState) walletLoadingState.style.display = 'flex';

                if (connectButton) {
                    connectButton.style.display = 'inline-block';
                    connectButton.disabled = true;
                    connectButton.textContent = 'Instalar Freighter';
                }
                if (disconnectButton) disconnectButton.style.display = 'none';

                if (walletAddressPanelDiv) walletAddressPanelDiv.style.display = 'none';
                if (walletInfoDiv) walletInfoDiv.style.display = 'none';
                if (userAddrSpan) userAddrSpan.textContent = 'No disponible';
                if (connStatusSpan) connStatusSpan.textContent = 'No disponible';

                disableActionButtons();
            }
        }

        // Habilitar botones de acción (requieren wallet)
        function enableActionButtons() {
            const buttons = ['create-btn', 'contrib-btn', 'finalize-btn', 'refund-btn'];
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = false;
            });
        }

        // Deshabilitar botones de acción (requieren wallet)
        function disableActionButtons() {
            const buttons = ['create-btn', 'contrib-btn', 'finalize-btn', 'refund-btn'];
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = true;
            });
        }

        // Habilitar botón de cargar pools (no requiere wallet)
        function enableLoadPoolsButton() {
            const btn = document.getElementById('load-pools-btn');
            if (btn) btn.disabled = false;
        }

        // Función para enviar logs al servidor
        async function sendLogToServer(level, message, data = null, operation = null) {
            try {
                await fetch('/api/log', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        level,
                        message,
                        data,
                        operation
                    })
                });
            } catch (error) {
                // Log removed
            }
        }

        // Función para enviar logs de transacciones al servidor
        async function sendTransactionLog(operation, details, status, error = null) {
            try {
                await fetch('/api/log-transaction', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        operation,
                        details,
                        status,
                        error
                    })
                });
            } catch (err) {
                // Log removed
            }
        }

        // Función para enviar logs de errores al servidor
        async function sendErrorLog(error, context, stack = null) {
            try {
                await fetch('/api/log-error', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        error: error.message || error,
                        context,
                        stack
                    })
                });
            } catch (err) {
                // Log removed
            }
        }

        // Función de compatibilidad para showAlert (ahora usa notificaciones)
        function showAlert(message, type = 'info') {
            const typeMap = {
                'success': 'success',
                'danger': 'error',
                'warning': 'warning',
                'info': 'info'
            };
            
            const notificationType = typeMap[type] || 'info';
            showNotification(notificationType, '', message, 5000);
        }

        // === FUNCIONES DE POOL (STUBS) ===


        // Verificar conectividad con el contrato
        async function verifyContractConnection() {
            try {
                // Log removed
                const account = await server.getAccount(userAddress);
                
                // Intentar una consulta simple al contrato usando get_pool
                const testTransaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(
                    StellarSdk.Operation.invokeContractFunction({
                        contract: CONFIG.contractId,
                        function: 'get_pool', // Función que existe
                        args: [StellarSdk.nativeToScVal(1, { type: 'u32' })]
                    })
                )
                .setTimeout(30)
                .build();

                // Solo simular la transacción, no enviarla
                const simulation = await server.simulateTransaction(testTransaction);
                // Log removed
                return simulation; // Return the full simulation result
            } catch (error) {
                // Log removed
                return { error: error.message }; // Return error object
            }
        }

        // Verificar si el contrato está inicializado
        async function isContractInitialized() {
            try {
                // Log removed
                const account = await server.getAccount(userAddress);
                
                // Intentar simular una operación que requiere inicialización
                // Usamos get_pool con ID 1 (que debería fallar si no está inicializado)
                const testTransaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(
                    StellarSdk.Operation.invokeContractFunction({
                        contract: CONFIG.contractId,
                        function: 'get_pool',
                        args: [StellarSdk.nativeToScVal(1, { type: 'u32' })]
                    })
                )
                .setTimeout(30)
                .build();

                const simulation = await server.simulateTransaction(testTransaction);
                
                // Si hay error con MissingValue, el contrato no está inicializado
                if (simulation.error && simulation.error.includes('MissingValue')) {
                    console.log('❌ Contrato NO inicializado (MissingValue detectado)');
                    return false;
                }
                
                // Si no hay error MissingValue, asumimos que está inicializado
                // Log removed
                return true;
                
            } catch (error) {
                // Log removed
                return false;
            }
        }

        async function initializeContract() {
            try {
                // Log removed
                showAlert('🔧 Inicializando contrato...', 'info');
                
                const account = await server.getAccount(userAddress);
                let tx = new StellarSdk.TransactionBuilder(account, { 
                    fee: StellarSdk.BASE_FEE, 
                    networkPassphrase: CONFIG.networkPassphrase 
                })
                .addOperation(StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'initialize',
                    args: []
                }))
                .setTimeout(60)
                .build();
                
                await server.simulateTransaction(tx);
                tx = await server.prepareTransaction(tx);
                
                const signed = await window.freighter.signTransaction(tx.toXDR(), { 
                    networkPassphrase: CONFIG.networkPassphrase, 
                    address: userAddress 
                });
                
                const xdr = signed.signedTxXdr ?? signed.signedXDR;
                const res = await server.sendTransaction(StellarSdk.TransactionBuilder.fromXDR(xdr, CONFIG.networkPassphrase));
                
                if (res.status !== 'SUCCESS') {
                    throw new Error('initialize falló: ' + res.status);
                }
                
                // Log removed
                showAlert('✅ Contrato inicializado exitosamente', 'success');
                return true;
                
            } catch (error) {
                // Log removed
                showAlert('❌ Error inicializando contrato: ' + error.message, 'danger');
                return false;
            }
        }

        // Inicializar el contrato si es necesario

        // Crear un nuevo pool de compra colectiva
        async function createPool() {
            if (!isConnected || !userAddress) {
                showAlert('❌ Conecta la wallet para crear un pool', 'danger');
                return;
            }

            try {
                // Verificar si el contrato está inicializado
                showAlert('🔍 Verificando estado del contrato...', 'info');
                const isInitialized = await isContractInitialized();
                
                if (!isInitialized) {
                    showAlert('🔧 El contrato no está inicializado. Inicializando automáticamente...', 'info');
                    const initSuccess = await initializeContract();
                    if (!initSuccess) {
                        showAlert('❌ No se pudo inicializar el contrato. Intenta nuevamente.', 'danger');
                        return;
                    }
                }

                // Obtener datos del formulario
                const rawName = (document.getElementById('pool-name')?.value || '').trim();
                if (!rawName) {
                    showAlert('❌ Ingresa un nombre para la cooperativa', 'danger');
                    return;
                }
                const poolName = rawName.replace(/\s+/g, ' ').slice(0, 40); // limpio + máximo 40
                
                const supplierAddress = document.getElementById('supplier').value.trim();
                const goalXlm = parseInt(document.getElementById('goal').value);
                // Parsear fecha de vencimiento desde datetime-local
                const deadlineStr = (document.getElementById('deadline')?.value || '').trim();
                if (!deadlineStr) {
                    showAlert('❌ Selecciona la fecha y hora de vencimiento', 'danger');
                    return;
                }

                // Parse robusto de datetime-local como hora local
                const [datePart, timePart] = deadlineStr.split('T');
                const [Y, M, D] = datePart.split('-').map(Number);
                const [h, m] = (timePart || '00:00').split(':').map(Number);
                const deadline = Math.floor(new Date(Y, M - 1, D, h, m).getTime() / 1000);

                const now = Math.floor(Date.now() / 1000);
                if (!Number.isFinite(deadline) || deadline <= now) {
                    showAlert('❌ La fecha de vencimiento debe ser futura', 'danger');
                    return;
                }

                // Debug: Log de la dirección obtenida
                // Validación básica del proveedor

                // Validaciones
                if (!supplierAddress) {
                    showAlert('❌ Ingresa la dirección del proveedor', 'danger');
                    return;
                }

                if (!goalXlm || goalXlm <= 0) {
                    showAlert('❌ La meta debe ser mayor a 0 XLM', 'danger');
                    return;
                }


                // Convertir XLM a stroops (1 XLM = 10,000,000 stroops)
                const goalStroops = BigInt(goalXlm * 10000000);
                
                
                // Validar longitud de la dirección (debe ser exactamente 56 caracteres)
                if (supplierAddress.length !== 56) {
                    showAlert(`❌ La dirección debe tener exactamente 56 caracteres. Tienes: ${supplierAddress.length}`, 'danger');
                    return;
                }

                // Validar formato de la dirección
                if (!supplierAddress.startsWith('G')) {
                    showAlert('❌ La dirección debe empezar con "G"', 'danger');
                    return;
                }

                // Validar que sea una dirección Stellar válida
                if (!StellarSdk.StrKey.isValidEd25519PublicKey(supplierAddress)) {
                    showAlert('❌ La dirección del proveedor no es válida. Debe ser una dirección Stellar válida', 'danger');
                    return;
                }
                
                // Verificar que la dirección sea diferente a la del usuario
                if (supplierAddress === userAddress) {
                    showAlert('❌ No puedes ser tu propio proveedor', 'danger');
                    return;
                }

                // Log removed
                // Log removed
                // Log removed
                console.log('⏰ Deadline:', new Date(deadline * 1000).toLocaleString());

                // Mostrar panel de proceso
                showProcessPanel();
                setProcessStep(1);
                updateProcessStatus('Creando transacción...');

                // Enviar log al servidor
                await sendLogToServer('info', 'Iniciando creación de pool', {
                    supplier: supplierAddress,
                    goal: goalXlm,
                    deadline: new Date(deadline * 1000).toISOString(),
                    contractId: CONFIG.contractId,
                    tokenId: CONFIG.tokenId
                }, 'CREATE_POOL');

                // Crear transacción para invocar el contrato
                let account;
                try {
                    account = await server.getAccount(userAddress);
                } catch (accountError) {
                    // Log removed
                    throw new Error('No se pudo obtener información de la cuenta. Verifica que la wallet tenga fondos suficientes.');
                }
                
                // Crear addresses necesarios
                let creatorAddress = StellarSdk.Address.fromString(userAddress);
                
                let tokenAddress = StellarSdk.Address.fromString(CONFIG.tokenId);
                let supplierAddressObj = StellarSdk.Address.fromString(supplierAddress);
                
                const goalScVal = StellarSdk.nativeToScVal(goalStroops, { type: 'i128' });
                const deadlineScVal = StellarSdk.nativeToScVal(deadline, { type: 'u64' });
                
                // Convertir addresses a ScVal
                const creatorScVal = StellarSdk.nativeToScVal(creatorAddress, { type: 'address' });
                const tokenScVal = StellarSdk.nativeToScVal(tokenAddress, { type: 'address' });
                const supplierScVal = StellarSdk.nativeToScVal(supplierAddressObj, { type: 'address' });
                
                // Log removed
                // Log removed
                // Log removed
                // Log removed
                // Log removed
                console.log('  - Deadline:', new Date(deadline * 1000).toLocaleString());
                
                // Debug: Verificar tipos de argumentos
                // Log removed
                // Log removed
                // Log removed
                // Log removed
                // Log removed
                // Log removed
                
                // Log removed
                
                // 1) Construir operación
                const operation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'create_pool',
                    args: [
                        creatorScVal,  // creator: Address
                        tokenScVal,    // token: Address
                        supplierScVal, // supplier: Address
                        goalScVal,     // goal: i128
                        deadlineScVal  // deadline: u64
                    ]
                });

                // 2) Armar transacción base
                let transaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(operation)
                .setTimeout(600) // 10 minutos para dar tiempo a Freighter
                .build();

                // Log removed

                // 3) Simular y preparar (footprint + resource fee + auth)
                // Log removed
                const simulation = await server.simulateTransaction(transaction);
                // Log removed
                
                if (simulation.error) {
                    throw new Error('Error en simulación: ' + simulation.error);
                }

                // Log removed
                transaction = await server.prepareTransaction(transaction);
                // Log removed

                // Log removed
                
                // Actualizar estado visual
                setProcessStep(2);
                updateProcessStatus('Firmando con Freighter...');
                
                await sendLogToServer('info', 'Firmando transacción con Freighter', null, 'CREATE_POOL');
                
                const signedTransaction = await window.freighter.signTransaction(transaction.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress  // unifica: usa 'address' para ser consistente
                });

                if (signedTransaction.error) {
                    // Log removed
                    await sendErrorLog(signedTransaction.error, 'Error firmando transacción', null);
                    
                    let errorMessage = 'Error firmando transacción';
                    if (typeof signedTransaction.error === 'string') {
                        errorMessage = signedTransaction.error;
                    } else if (signedTransaction.error.message) {
                        errorMessage = signedTransaction.error.message;
                    } else {
                        errorMessage = JSON.stringify(signedTransaction.error);
                    }
                    
                    throw new Error(errorMessage);
                }

                // Log removed
                
                // Actualizar estado visual
                setProcessStep(3);
                updateProcessStatus('Enviando a la red...');
                
                // 4) Enviar - usar fallback para ambas variantes de Freighter
                const signedXdr = signedTransaction.signedTxXdr ?? signedTransaction.signedXDR;
                if (!signedXdr) {
                    throw new Error('Freighter no retornó XDR firmada (signedTxXdr/signedXDR)');
                }
                
                const transactionToSubmit = StellarSdk.TransactionBuilder.fromXDR(
                    signedXdr,
                    CONFIG.networkPassphrase
                );

                const response = await server.sendTransaction(transactionToSubmit);
                // Log removed
                // Log removed

                if (response.status === 'SUCCESS') {
                    // Actualizar estado visual
                    setProcessStep(5);
                    updateProcessStatus('Procesando resultado...', false);
                    
                    // Obtener poolId usando getPoolIdFromTx como método principal
                    const poolId = await getPoolIdFromTx(response.hash);
                    
                    await sendTransactionLog('CREATE_POOL', {
                        poolId: poolId,
                        supplier: supplierAddress,
                        goal: goalXlm,
                        deadline: new Date(deadline * 1000).toISOString()
                    }, 'success');
                    
                    showAlert(`✅ Pool creado exitosamente! ID: ${poolId}`, 'success');
                    
                    // Cargar información del pool recién creado
                    if (poolId) {
                        // 1) Preinyecta nombre para que getPoolInfo lo recoja y pinte bien
                        activePoolsCache.set(String(poolId), { id: poolId, name: poolName });
                        
                        const info = await getPoolInfo(poolId);         // 👉 devuelve { pool, status }
                        if (!info || !info.pool) return;

                        // 2) Asigna y re-renderiza por si acaso
                        info.pool.name = poolName;
                        renderPoolCard(poolId, info.pool, info.status);

                        // Recordar y refrescar UI
                        rememberActivePool(info.pool);
                        refreshContribDropdownFromCache();

                        // Persistir en backend (archivo data/pools_state.json)
                        try {
                            await fetch('/api/pools/register', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ pool: normalizePoolForBackend(info.pool) }, jsonBigIntReplacer)
                            });
                        } catch (_) {}

                        // Guardar snapshot local coherente
                        try {
                            const raw = localStorage.getItem('pools_snapshot');
                            const list = raw ? JSON.parse(raw) : [];
                            const without = list.filter(p => String(p.id) !== String(info.pool.id));
                            const normalized = { ...normalizePoolForBackend(info.pool), status: info.status || 'active' };
                            without.push(normalized);
                            localStorage.setItem('pools_snapshot', JSON.stringify(without, jsonBigIntReplacer));
                        } catch (_) {}
                    }
                    
                    // Limpiar formulario y ocultar panel
                    document.getElementById('pool-name').value = '';
                    document.getElementById('supplier').value = '';
                    document.getElementById('goal').value = '100';
                    // Reset fecha de vencimiento a +30 días
                    const dft = new Date(); 
                    dft.setDate(dft.getDate() + 30);
                    const defStr = formatLocalDatetime(dft);
                    const dlEl = document.getElementById('deadline');
                    if (dlEl) dlEl.value = defStr;
                    hideProcessPanel();
                    
                } else if (response.status === 'PENDING') {
                    // Actualizar estado visual
                    setProcessStep(4);
                    updateProcessStatus('Esperando confirmación...');
                    showProcessHash(response.hash);
                    
                    // Almacenar hash para verificación posterior
                    storeLastTransaction(response.hash);
                    showAlert(`⏳ Transacción pendiente\nHash: ${response.hash}\nEsperando confirmación...`, 'info');

                    try {
                        // Usar watcher automático
                        const final = await waitForTx(response.hash);
                        if (final.status === 'SUCCESS') {
                            // Actualizar estado visual
                            setProcessStep(5);
                            updateProcessStatus('¡Pool confirmado!', false);
                            
                            showAlert('✅ ¡Pool confirmado on-chain!', 'success');
                            
                            // Extraer poolId y cargar información
                            const poolId = await getPoolIdFromTx(response.hash);
                            
                            if (poolId) {
                                // Preinyecta el nombre ANTES de consultar para que el render ya lo tenga
                                activePoolsCache.set(String(poolId), { id: poolId, name: poolName });
                                
                                const info = await getPoolInfo(poolId);
                                if (info && info.pool) {
                                    const pool = info.pool;
                                    pool.name = poolName;             // cinturón y tirantes
                                    renderPoolCard(poolId, pool, info.status);

                                    // Recordar y refrescar UI
                                    rememberActivePool(pool);
                                    refreshContribDropdownFromCache();

                                    // Registrar en backend
                                    try {
                                        await fetch('/api/pools/register', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({ pool: normalizePoolForBackend(pool) }, jsonBigIntReplacer)
                                        });
                                    } catch (_) {}

                                    // Actualizar snapshot local
                                    try {
                                        const raw = localStorage.getItem('pools_snapshot');
                                        const list = raw ? JSON.parse(raw) : [];
                                        const without = list.filter(p => String(p.id) !== String(pool.id));
                                        const normalized = { ...normalizePoolForBackend(pool), status: info.status || 'active' };
                                        without.push(normalized);
                                        localStorage.setItem('pools_snapshot', JSON.stringify(without, jsonBigIntReplacer));
                                    } catch (_) {}

                                    // UI (opcional): recordar y refrescar dropdown
                                    rememberActivePool(pool);
                                    refreshContribDropdownFromCache();
                                }
                                // Limpiar formulario y ocultar panel
                                document.getElementById('supplier').value = '';
                                document.getElementById('goal').value = '100';
                                // Reset fecha de vencimiento a +30 días
                    const dft = new Date(); 
                    dft.setDate(dft.getDate() + 30);
                    const defStr = formatLocalDatetime(dft);
                    const dlEl = document.getElementById('deadline');
                    if (dlEl) dlEl.value = defStr;
                                setTimeout(() => hideProcessPanel(), 2000);
                            } else {
                                showAlert('⚠️ Pool creado pero no se pudo obtener el ID', 'warning');
                                hideProcessPanel();
                            }
                        } else {
                            updateProcessStatus('Transacción falló', false);
                            showAlert('❌ La transacción falló', 'danger');
                            // Log removed
                            setTimeout(() => hideProcessPanel(), 3000);
                        }
                    } catch (e) {
                        updateProcessStatus('Expiró la espera', false);
                        showAlert('⌛ Expiró la espera de confirmación', 'warning');
                        // Log removed
                        setTimeout(() => hideProcessPanel(), 3000);
                    }
                } else {
                    await sendTransactionLog('CREATE_POOL', {
                        supplier: supplierAddress,
                        goal: goalXlm,
                        deadline: new Date(deadline * 1000).toISOString()
                    }, 'error', response.status);
                    
                    // Mostrar error más específico
                    let errorMessage = 'La transacción falló: ' + response.status;
                    if (response.errorResult) {
                        console.log('❌ Error details:', JSON.stringify(response.errorResult));
                        errorMessage += '\nDetalles: ' + JSON.stringify(response.errorResult);
                        
                        // Analizar tipo de error específico
                        if (response.errorResult.result && response.errorResult.result._switch) {
                            const errorType = response.errorResult.result._switch.name;
                            // Log removed
                            
                            if (errorType === 'txMalformed') {
                                errorMessage += '\n💡 Error: Transacción malformada. Verifica los argumentos del contrato.';
                            } else if (errorType === 'txFailed') {
                                errorMessage += '\n💡 Error: Transacción falló. Verifica que el contrato esté inicializado.';
                            }
                        }
                    }
                    throw new Error(errorMessage);
                }

            } catch (error) {
                // Log removed
                await sendErrorLog(error, 'Error en createPool', error.stack);
                
                // Ocultar panel de proceso en caso de error
                updateProcessStatus('Error en el proceso', false);
                setTimeout(() => hideProcessPanel(), 3000);
                
                let errorMessage = 'Error desconocido';
                if (error.message) {
                    errorMessage = error.message;
                } else if (typeof error === 'string') {
                    errorMessage = error;
                } else {
                    errorMessage = JSON.stringify(error);
                }
                
                showAlert('❌ Error creando pool: ' + errorMessage, 'danger');
            }
        }

        // 🔧 Convierte BigInt → string y deja números/strings planos
        function normalizePoolForBackend(pool) {
            return {
                id: Number(pool.id),
                name: String(pool.name || ''),    // 👈 nuevo
                creator: String(pool.creator),
                supplier: String(pool.supplier),
                token: String(pool.token),
                goal: pool.goal != null ? String(pool.goal) : "0",
                raised: pool.raised != null ? String(pool.raised) : "0",
                deadline: Number(pool.deadline),
                finalized: Boolean(pool.finalized),
            };
        }

        // Opcional general: replacer para JSON.stringify en cualquier objeto
        function jsonBigIntReplacer(_k, v) {
            return typeof v === 'bigint' ? v.toString() : v;
        }

        // Lee la pool on-chain y garantiza que el backend la tenga registrada
        async function ensureServerHasPool(poolId) {
            // 1) Consulta on-chain (tu función existente que decodifica el struct)
            const info = await getPoolInfo(poolId); // debe devolver { pool: {...}, status: ... }
            if (!info || !info.pool) {
                throw new Error('No se pudo leer el pool on-chain para registrarlo en el backend');
            }

            // 2) Registra en el backend
            const plain = normalizePoolForBackend(info.pool);
            await fetch('/api/pools/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ pool: plain }, jsonBigIntReplacer)
            });

            return info.pool;
        }

        // Repoblar el backend al arrancar (tras F5)
        async function selfHealBackendFromSnapshot() {
            try {
                const raw = localStorage.getItem('pools_snapshot');
                const list = raw ? JSON.parse(raw) : [];
                if (!Array.isArray(list) || list.length === 0) return;

                // Verifica una por una; si no está, la registra
                for (const p of list) {
                    const id = String(p.id);
                    const r = await fetch(`/api/pools/${id}`);
                    if (r.status === 404) {
                        // Log removed
                        const plain = normalizePoolForBackend(p);
                        await fetch('/api/pools/register', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ pool: plain }, jsonBigIntReplacer)
                        });
                    }
                }
            } catch (e) {
                // Log removed
            }
        }

        // Contribuir a un pool existente
        async function contributeToPool() {
            if (!isConnected || !userAddress) {
                showAlert('❌ Conecta la wallet para contribuir', 'danger');
                return;
            }

            try {
                // Obtener datos del formulario
                const sel = document.getElementById('contrib-pool-select');
                let poolId = sel && sel.value ? Number(sel.value) : NaN;

                // Fallback (si dejaste el input oculto y quieres permitir pegar manualmente)
                if (!Number.isFinite(poolId) || poolId <= 0) {
                    const fallback = document.getElementById('contrib-pool-id');
                    if (fallback && fallback.value) poolId = Number(fallback.value);
                }

                if (!Number.isFinite(poolId) || poolId <= 0) {
                    showAlert('❌ Selecciona una cooperativa activa', 'danger');
                    return;
                }

                // Validar que la pool existe y está activa
                // Log removed
                let pool;
                try {
                    // Validación en backend
                    let res = await fetch(`/api/pools/${poolId}`);
                    if (res.status === 404) {
                        // Log removed
                        try {
                            await ensureServerHasPool(poolId);      // <- nuevo
                            res = await fetch(`/api/pools/${poolId}`); // reintenta
                        } catch (e) {
                            showAlert(`❌ No se pudo registrar la pool #${poolId} en el backend. ${e.message}`, 'danger');
                            throw e;
                        }
                    }
                    if (!res.ok) {
                        const msg = await res.text().catch(()=>'');
                        showAlert(`❌ Error validando pool (#${poolId}): ${msg || res.status}`, 'danger');
                        return;
                    }

                    pool = await res.json();
                    
                    // Verificar que la pool no esté finalizada
                    if (pool.finalized) {
                        throw new Error(`Pool #${poolId} ya está finalizada`);
                    }
                    
                    // Verificar que no haya expirado
                    const now = Math.floor(Date.now() / 1000);
                    if (now > Number(pool.deadline)) {
                        throw new Error(`Pool #${poolId} ha expirado`);
                    }
                    
                    // Log removed
                } catch (e) {
                    // Log removed
                    showAlert('❌ Error validando cooperativa: ' + e.message, 'danger');
                    return;
                }

                // Validaciones
                if (!poolId || poolId <= 0) {
                    showAlert('❌ Ingresa un ID de pool válido', 'danger');
                    return;
                }

                // --- MONTO DEL USUARIO ---
                const amountXlm = parseFloat(document.getElementById('contrib-amount').value);

                // Validaciones básicas existentes…
                if (!Number.isFinite(amountXlm) || amountXlm <= 0) {
                    showAlert('❌ La cantidad debe ser mayor a 0 XLM', 'danger');
                    return;
                }

                // Convertir XLM a stroops
                let amountStroops = BigInt(Math.round(amountXlm * 1e7));

                // === (3) TOPE DURO: recorte previo al approve según RESTANTE ACTUAL ===
                const remainingStroops = BigInt(pool.goal) - BigInt(pool.raised);
                if (remainingStroops <= 0n) {
                    showAlert('Esta cooperativa ya está financiada; no puedes aportar más.', 'warning');
                    return;
                }

                let effectiveStroops = amountStroops > remainingStroops ? remainingStroops : amountStroops;
                if (effectiveStroops !== amountStroops) {
                    const effXlm = (Number(effectiveStroops) / 1e7).toFixed(7);
                    showAlert(`Tu aporte excedía el máximo permitido; se ajustó a ${effXlm} XLM.`, 'info');
                }

                // Mostrar panel de proceso (lo tienes ya)
                showProcessPanel();
                setProcessStep(1);
                updateProcessStatus('Verificando balance de XLM...');

                // Asegura que tenemos XLM envuelto suficiente SOLO por el recorte "efectivo"
                await ensureWrappedXlm(effectiveStroops, pool.token);

                // --- APPROVE por el monto EFECTIVO ---
                setProcessStep(2);
                updateProcessStatus('Preparando aprobación...');

                const account = await server.getAccount(userAddress);
                const { sequence } = await server.getLatestLedger();
                const expirationLedger = sequence + 1000;

                const fromScVal    = StellarSdk.nativeToScVal(StellarSdk.Address.fromString(userAddress), { type: 'address' });
                const spenderScVal = StellarSdk.nativeToScVal(StellarSdk.Address.fromString(CONFIG.contractId), { type: 'address' });
                const amountScVal  = StellarSdk.nativeToScVal(effectiveStroops, { type: 'i128' });
                const expScVal     = StellarSdk.nativeToScVal(expirationLedger, { type: 'u32' });

                const approveOperation = StellarSdk.Operation.invokeContractFunction({
                    contract: pool.token,
                    function: 'approve',
                    args: [fromScVal, spenderScVal, amountScVal, expScVal]
                });

                let approveTransaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(approveOperation)
                .setTimeout(600)
                .build();

                setProcessStep(3);
                updateProcessStatus('Simulando aprobación...');
                const approveSimulation = await server.simulateTransaction(approveTransaction);
                if (approveSimulation.error) throw new Error('Error en simulación de approve: ' + approveSimulation.error);

                setProcessStep(4);
                updateProcessStatus('Preparando aprobación...');
                approveTransaction = await server.prepareTransaction(approveTransaction);

                const signedApprove = await window.freighter.signTransaction(approveTransaction.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress
                });
                if (signedApprove.error) throw new Error('Error firmando approve: ' + signedApprove.error);

                const approveSignedXdr = signedApprove.signedTxXdr ?? signedApprove.signedXDR;
                const approveToSubmit = StellarSdk.TransactionBuilder.fromXDR(approveSignedXdr, CONFIG.networkPassphrase);
                const approveResponse = await server.sendTransaction(approveToSubmit);
                if (approveResponse.status === 'PENDING') {
                    const final = await waitForTx(approveResponse.hash);
                    if (final.status !== 'SUCCESS') throw new Error('Approve no se confirmó: ' + final.status);
                } else if (approveResponse.status !== 'SUCCESS') {
                    throw new Error('Approve falló: ' + approveResponse.status);
                }

                // === DOBLE CHEQUEO ANTI-CARRERA ANTES DE CONTRIBUTE ===
                // (otra contribución pudo entrar en medio)
                const latest = await getPoolInfo(poolId); // read-only
                if (!latest || !latest.pool) throw new Error('No se pudo refrescar el estado de la cooperativa');
                const latestRemaining = BigInt(latest.pool.goal) - BigInt(latest.pool.raised);
                if (latestRemaining <= 0n) {
                    showAlert('Mientras preparabas la transacción, la cooperativa llegó al tope.', 'warning');
                    return;
                }
                if (effectiveStroops > latestRemaining) {
                    effectiveStroops = latestRemaining; // recorte final
                }

                // --- CONTRIBUTE por el EFECTIVO (recortado) ---
                setProcessStep(5);
                updateProcessStatus('Preparando contribución...');

                const userScVal = StellarSdk.nativeToScVal(StellarSdk.Address.fromString(userAddress), { type: 'address' });
                const contributeOperation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'contribute',
                    args: [
                        StellarSdk.nativeToScVal(poolId, { type: 'u32' }),
                        userScVal,
                        StellarSdk.nativeToScVal(effectiveStroops, { type: 'i128' })
                    ]
                });

                let contributeTransaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(contributeOperation)
                .setTimeout(600)
                .build();

                const contributeSimulation = await server.simulateTransaction(contributeTransaction);
                if (contributeSimulation.error) throw new Error('Error en simulación de contribute: ' + contributeSimulation.error);

                contributeTransaction = await server.prepareTransaction(contributeTransaction);

                const signedContribute = await window.freighter.signTransaction(contributeTransaction.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress
                });
                if (signedContribute.error) throw new Error('Error firmando contribute: ' + signedContribute.error);

                const contributeSignedXdr = signedContribute.signedTxXdr ?? signedContribute.signedXDR;
                const contributeToSubmit = StellarSdk.TransactionBuilder.fromXDR(contributeSignedXdr, CONFIG.networkPassphrase);
                const contributeResponse = await server.sendTransaction(contributeToSubmit);

                if (contributeResponse.status === 'PENDING') {
                    storeLastTransaction(contributeResponse.hash);
                    showProcessHash(contributeResponse.hash);
                    updateProcessStatus('⏳ Esperando confirmación de contribución...');
                    const final = await waitForTx(contributeResponse.hash);
                    if (final.status !== 'SUCCESS') throw new Error(`La contribución falló on-chain: ${final.status}`);
                } else if (contributeResponse.status !== 'SUCCESS') {
                    throw new Error(`La contribución no fue aceptada: ${contributeResponse.status}`);
                }

                // Éxito
                setProcessStep(6);
                updateProcessStatus('✅ Contribución confirmada');
                const effXlm = (Number(effectiveStroops) / 1e7).toFixed(7);
                showAlert(`✅ ¡Contribución exitosa! ${effXlm} XLM al pool ${poolId}`, 'success');

                // 🔄 Refrescar la tarjeta del pool (con pequeño retardo para consistencia eventual)
                try {
                    // Asegura que el selector de "Acciones" también apunte a este pool
                    const _inp = document.getElementById('action-pool-id');
                    if (_inp) _inp.value = String(poolId);
                    // Pequeño retardo para asegurar consistencia eventual
                    setTimeout(async () => {
                        try {
                            const info = await getPoolInfo(poolId);   // <- vuelve a simular get_pool y re-renderiza
                            // 🔄 Sincronizar con backend después de contribuir
                            if (info?.pool) {
                                await fetch('/api/pools/register', {
                                    method: 'POST',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({ pool: normalizePoolForBackend(info.pool) })
                                });
                            }
                        } catch (e) {
                            // Log removed
                        }
                    }, 1200);
                } catch (e) {
                    // Log removed
                }
                
                // Limpiar formulario y ocultar panel
                document.getElementById('contrib-amount').value = '10';
                setTimeout(() => hideProcessPanel(), 2000);

            } catch (error) {
                // Log removed
                showAlert('❌ Error contribuyendo: ' + error.message, 'danger');
                setTimeout(() => hideProcessPanel(), 3000);
            }
        }

        // Finalizar un pool (solo el creador)
        // Finalizar un pool (solo el creador)
        async function finalizePool(poolIdParam) {
            if (!isConnected || !userAddress) {
                showAlert('❌ Conecta la wallet para finalizar', 'danger'); return;
            }
            const poolId = Number(poolIdParam ?? document.getElementById('action-pool-id')?.value);
            if (!Number.isFinite(poolId) || poolId <= 0) {
                showAlert('❌ Ingresa un ID de pool válido', 'danger'); return;
            }

            try {

                // Mostrar panel de proceso
                showProcessPanel();
                setProcessStep(1);
                updateProcessStatus('Creando transacción de finalización…');

                // (Opcional) Traer datos del pool para el mensaje de éxito
                let raisedXlm = null, supplierShort = '';
                try {
                    const res = await getPoolInfo(poolId); // read-only (simulación)
                    if (res?.pool) {
                        raisedXlm = (Number(res.pool.raised) / 1e7).toFixed(2);
                        const s = String(res.pool.supplier);
                        supplierShort = `${s.slice(0,6)}…${s.slice(-4)}`;
                    }
                } catch(_) {}

                const account = await server.getAccount(userAddress);

                // --- Construir operación con 2 argumentos: pool_id y creator(Address)
                const operation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'finalize',
                    args: [
                        StellarSdk.nativeToScVal(poolId, { type: 'u32' }),
                        StellarSdk.nativeToScVal(
                            StellarSdk.Address.fromString(userAddress),
                            { type: 'address' }
                        )
                    ]
                });

                let tx = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(operation)
                .setTimeout(600)
                .build();

                setProcessStep(2);
                updateProcessStatus('Simulando y preparando…');
                const sim = await server.simulateTransaction(tx);
                if (sim.error) throw new Error('Error en simulación: ' + sim.error);

                tx = await server.prepareTransaction(tx);

                setProcessStep(3);
                updateProcessStatus('Firmando con Freighter…');
                const signed = await window.freighter.signTransaction(tx.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress
                });
                if (signed.error) throw new Error(signed.error);
                const signedXdr = signed.signedTxXdr ?? signed.signedXDR;
                const txToSubmit = StellarSdk.TransactionBuilder.fromXDR(
                    signedXdr,
                    CONFIG.networkPassphrase
                );

                setProcessStep(4);
                updateProcessStatus('Enviando a la red…');
                const submit = await server.sendTransaction(txToSubmit);

                if (submit.status === 'PENDING') {
                    storeLastTransaction(submit.hash);
                    showProcessHash(submit.hash);
                    updateProcessStatus('⏳ Esperando confirmación de finalización.');
                    const final = await waitForTx(submit.hash);
                    if (final.status !== 'SUCCESS') {
                        throw new Error(`La finalización falló on-chain: ${final.status}`);
                    }
                } else if (submit.status !== 'SUCCESS') {
                    throw new Error('La finalización no fue aceptada: ' + submit.status);
                }

                // Éxito on-chain
                setProcessStep(5, 'completed');
                updateProcessStatus('✅ XLM enviados al proveedor.', false);
                showAlert(
                    `✅ Pool ${poolId} finalizado. ${raisedXlm ?? ''} XLM enviados al proveedor ${supplierShort}.`,
                    'success'
                );

                // Limpiar watcher de deadline (ya no es necesario)
                clearDeadlineWatcher(poolId);

                // Refrescar card del pool (marcará "Finalizado")
                const _inp = document.getElementById('action-pool-id');
                if (_inp) _inp.value = String(poolId);
                setTimeout(async () => { 
                    try { 
                        const info = await getPoolInfo(poolId);
                        // 🔄 Sincronizar con backend después de finalizar
                        if (info?.pool) {
                            await fetch('/api/pools/register', {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({ pool: normalizePoolForBackend(info.pool) })
                            });
                        }
                    } catch(_){} 
                }, 1200);
                setTimeout(() => hideProcessPanel(), 2000);

            } catch (error) {
                // Log removed
                showAlert('❌ Error finalizando pool: ' + error.message, 'danger');
                setTimeout(() => hideProcessPanel(), 3000);
            }
        }

        // Solicitar reembolso de un pool fallido
        async function requestRefund(poolIdParam) {
            if (!isConnected || !userAddress) {
                showAlert('❌ Conecta la wallet para solicitar reembolso', 'danger'); return;
            }
            const poolId = Number(poolIdParam ?? document.getElementById('action-pool-id')?.value);
            if (!Number.isFinite(poolId) || poolId <= 0) {
                showAlert('❌ Ingresa un ID de pool válido', 'danger'); return;
            }

            try {

                // Mostrar notificación informativa
                showAlert(`🔁 Preparando reembolso de la cooperativa #${poolId}...`, 'info');

                // Log removed
                // Log removed

                // Mostrar panel de proceso
                showProcessPanel();
                setProcessStep(1);
                updateProcessStatus('🔍 Simulando reembolso...');

                const account = await server.getAccount(userAddress);
                
                // 1) Construir operación con 2 argumentos: pool_id y user(Address)
                const operation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'refund',
                    args: [
                        StellarSdk.nativeToScVal(poolId, { type: 'u32' }),
                        StellarSdk.nativeToScVal(
                            StellarSdk.Address.fromString(userAddress),
                            { type: 'address' }
                        )
                    ]
                });

                // 2) Armar transacción base
                let transaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(operation)
                .setTimeout(600) // 10 minutos para dar tiempo a Freighter
                .build();

                // 3) Simular y preparar
                setProcessStep(2);
                updateProcessStatus('🔧 Preparando transacción...');
                
                const simulation = await server.simulateTransaction(transaction);
                if (simulation.error) {
                    throw new Error('Error en simulación: ' + simulation.error);
                }

                transaction = await server.prepareTransaction(transaction);

                // 4) Firmar
                setProcessStep(3);
                updateProcessStatus('✍️ Firmando con Freighter...');
                
                const signedTransaction = await window.freighter.signTransaction(transaction.toXDR(), {
                    networkPassphrase: CONFIG.networkPassphrase,
                    address: userAddress
                });

                if (signedTransaction.error) {
                    throw new Error(signedTransaction.error);
                }

                const signedXdr = signedTransaction.signedTxXdr ?? signedTransaction.signedXDR;
                if (!signedXdr) {
                    throw new Error('Freighter no retornó XDR firmada (signedTxXdr/signedXDR)');
                }

                const transactionToSubmit = StellarSdk.TransactionBuilder.fromXDR(
                    signedXdr,
                    CONFIG.networkPassphrase
                );

                // 5) Enviar a la red
                setProcessStep(4);
                updateProcessStatus('Enviando a la red…');
                
                const submit = await server.sendTransaction(transactionToSubmit);
                // Log removed

                // 6) Manejar respuesta (PENDING o SUCCESS)
                if (submit.status === 'PENDING') {
                    storeLastTransaction(submit.hash);
                    showProcessHash(submit.hash);
                    updateProcessStatus('⏳ Esperando confirmación de reembolso.');
                    const final = await waitForTx(submit.hash);
                    if (final.status !== 'SUCCESS') {
                        throw new Error(`El reembolso falló on-chain: ${final.status}`);
                    }
                } else if (submit.status !== 'SUCCESS') {
                    throw new Error('El reembolso no fue aceptado: ' + submit.status);
                }

                // 7) Éxito on-chain: reflejar en UI
                setProcessStep(5, 'completed');
                updateProcessStatus('✅ Reembolso recibido.', false);
                showAlert(`✅ Reembolso de la cooperativa #${poolId} confirmado on-chain.`, 'success');

                // Limpiar watcher de deadline (ya no es necesario)
                clearDeadlineWatcher(poolId);

                // Refrescar card del pool
                const info = await getPoolInfo(poolId);
                // 🔄 Sincronizar con backend después de reembolsar
                if (info?.pool) {
                    await fetch('/api/pools/register', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ pool: normalizePoolForBackend(info.pool) })
                    });
                }
                
                // Cerrar el panel visual después de un momento
                setTimeout(() => hideProcessPanel(), 2000);

            } catch (error) {
                // Log removed
                showAlert('❌ Error solicitando reembolso: ' + error.message, 'danger');
                hideProcessPanel();
            }
        }

        // Consultar información de un pool (read-only, sin firmar)
        async function getPoolInfo(poolId = null) {
            if (!isConnected) {
                showAlert('❌ Conecta la wallet para ver información', 'danger');
                return;
            }

            try {
                // Si no se pasa poolId, obtenerlo del formulario
                if (!poolId) {
                    poolId = parseInt(document.getElementById('action-pool-id').value);
                    if (!poolId || poolId <= 0) {
                        showAlert('❌ Ingresa un ID de pool válido', 'danger');
                        return;
                    }
                }

                // Consultando pool (read-only)

                const account = await server.getAccount(userAddress);
                
                // 1) Construir operación
                const operation = StellarSdk.Operation.invokeContractFunction({
                    contract: CONFIG.contractId,
                    function: 'get_pool',
                    args: [
                        StellarSdk.nativeToScVal(poolId, { type: 'u32' }) // pool_id
                    ]
                });

                // 2) Armar transacción base
                let transaction = new StellarSdk.TransactionBuilder(account, {
                    fee: StellarSdk.BASE_FEE,
                    networkPassphrase: CONFIG.networkPassphrase,
                })
                .addOperation(operation)
                .setTimeout(600) // 10 minutos para dar tiempo a Freighter
                .build();

                // 3) Solo simular (read-only)
                // Simulando consulta de pool
                const simulation = await server.simulateTransaction(transaction);
                if (simulation.error) {
                    throw new Error('Error en simulación: ' + simulation.error);
                }

                // Decodificar el returnValue (ScVal -> JS)
                const scv = simulation.result?.retval ?? simulation.result?.returnValue ?? simulation.returnValue;
                if (!scv) {
                    throw new Error('Sin returnValue en la simulación');
                }

                const pool = StellarSdk.scValToNative(scv);
                // Datos del pool decodificados
                
                // Preservar nombre del cache si existe
                const existing = activePoolsCache.get(String(poolId));
                if (existing?.name && !pool.name) pool.name = existing.name;

                // Calcular estado del pool
                const now = Math.floor(Date.now() / 1000);
                const expired = now > pool.deadline;
                const funded = BigInt(pool.raised) >= BigInt(pool.goal);
                const status = pool.finalized ? 'finalized'
                             : expired && !funded ? 'expired'
                             : funded ? 'funded'
                             : 'active';

                // Solo programar si aún NO está vencido ni finalizado
                if (!expired && !pool.finalized) {
                    scheduleDeadlineWatcher(poolId, pool.deadline);
                }

                // Renderizar tarjeta del pool
                renderPoolCard(poolId, pool, status);

                // Recordar el pool activo y refrescar dropdown
                rememberActivePool(pool);
                refreshContribDropdownFromCache();

                // Validar y habilitar/deshabilitar botón de reembolso
                const refundBtn = document.getElementById('refund-btn');
                if (refundBtn) {
                    const canRefundPool = canRefund(pool);
                    refundBtn.disabled = !canRefundPool;
                    
                    // Tooltip explicativo
                    if (!canRefundPool) {
                        refundBtn.title = 'Solo disponible si el plazo venció y no se llegó a la meta.';
                    } else {
                        refundBtn.title = '';
                    }
                }

                return { pool, status };

            } catch (error) {
                // Error consultando pool
                showAlert('❌ Error consultando pool: ' + error.message, 'danger');
                return null;
            }
        }

        // Renderizar tarjeta del pool en la UI
        function renderPoolCard(poolId, pool, status) {
            const grid = document.getElementById('pools-grid');
            
            // Crear o actualizar tarjeta del pool
            let poolCard = document.getElementById(`pool-${poolId}`);
            if (!poolCard) {
                poolCard = document.createElement('div');
                poolCard.id = `pool-${poolId}`;
                poolCard.className = 'pool-card-scroll';
                grid.appendChild(poolCard);
            }

            // Calcular progreso
            const progress = Number(pool.raised) / Number(pool.goal) * 100;
            const progressPct = Math.min(progress, 100); // 👈 capar a 100% máximo
            const goalXlm = Number(pool.goal) / 10000000;
            const raisedXlm = Number(pool.raised) / 10000000;
            const deadline = new Date(Number(pool.deadline) * 1000);

            // Mapear estados a clases CSS
            const statusClass = {
                'active': 'status-active',
                'funded': 'status-funded', 
                'finalized': 'status-funded',
                'expired': 'status-expired'
            }[status] || 'status-active';

            const statusText = {
                'active': 'Activo',
                'funded': 'Financiado',
                'finalized': 'Finalizado',
                'expired': 'Expirado'
            }[status] || 'Activo';

            const displayName = (pool.name && pool.name.trim()) ? pool.name.trim() : `Pool #${poolId}`;
            poolCard.innerHTML = `
                <div class="pool-header">
                    <span class="pool-name" title="${displayName}">${displayName}</span>
                    <span class="pool-status ${statusClass}">${statusText}</span>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${Math.min(progress, 100)}%"></div>
                </div>
                
                <div class="pool-info">
                    <div class="info-item">
                        <div class="info-label">Meta</div>
                        <div class="info-value">${goalXlm} XLM</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Recaudado</div>
                        <div class="info-value">${raisedXlm} XLM</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Progreso</div>
                        <div class="info-value">${progressPct.toFixed(1)}%</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Deadline</div>
                        <div class="info-value">${deadline.toLocaleDateString()}</div>
                    </div>
                </div>
                
                ${status === 'funded' && userAddress === pool.creator ? `
                    <div class="pool-actions" style="margin-top: 15px; text-align: center;">
                        <button class="btn btn-success" onclick="finalizePoolFromCard(${poolId})" style="width: 100%;">
                            💳 Finalizar y Pagar al Proveedor
                        </button>
                        <small style="color: #666; font-size: 0.9em; display: block; margin-top: 5px;">
                            Meta alcanzada - Listo para pagar
                        </small>
                    </div>
                ` : ''}

                <!-- Botón de reembolso por tarjeta: visible solo si el pool está vencido y no financiado -->
                ${status === 'expired' ? `
                    <div class="pool-actions" style="margin-top: 15px; text-align: center;">
                        <button class="btn btn-danger" onclick="refundPoolFromCard(${poolId})" style="width: 100%;">
                            💰 Obtener Reembolso
                        </button>
                        <small style="color: #666; font-size: 0.9em; display: block; margin-top: 5px;">
                            Cooperativa vencida sin llegar a la meta
                        </small>
                    </div>
                ` : ''}
                
            `;
        }

        // Finalizar pool desde la tarjeta (cuando está financiado)
        async function finalizePoolFromCard(poolId) {
            await finalizePool(poolId);
        }

        // Reembolsar pool desde la tarjeta (cuando está vencido y sin financiar)
        async function refundPoolFromCard(poolId) {
            await requestRefund(poolId);
        }

        // --- Intenta extraer poolId desde el returnValue
        async function getPoolIdFromReturnValue(hash) {
            try {
                const tx = await safeGetTransaction(hash);
                if (tx.status !== 'SUCCESS') return null;

                // posibles ubicaciones del retorno según SDK/RPC
                const raw = tx.returnValue ?? tx.result?.retval ?? tx.result?.returnValue;
                const scv = toScVal(raw);
                if (!scv) return null;

                const native = StellarSdk.scValToNative(scv);
                const id = (native && typeof native === 'object' && 'id' in native) ? native.id : native;
                const n = Number(id);
                return Number.isFinite(n) ? n : null;
            } catch (e) {
                console.error('Error extrayendo poolId (returnValue):', e);
                return null;
            }
        }

        // --- Fallback: leer poolId desde eventos de la TX
        async function getPoolIdFromEventsByTx(hash) {
            try {
                const tx = await safeGetTransaction(hash);
                if (tx.status !== 'SUCCESS') return null;

                const ev = await server.getEvents({
                    startLedger: tx.ledger,
                    filters: [{ type: 'contract', contractIds: [CONFIG.contractId] }],
                });

                const event = ev.events.find(e => e.txHash === hash);
                if (!event) return null;

                // value puede estar en varias formas según el endpoint
                const raw = event?.value?.xdr || event?.value || event?.data?.xdr || event?.data;
                const scv = toScVal(raw);
                if (!scv) return null;

                const native = StellarSdk.scValToNative(scv);
                const id = (native && typeof native === 'object' && 'id' in native) ? native.id : native;
                const n = Number(id);
                return Number.isFinite(n) ? n : null;
            } catch (e) {
                console.error('Error extrayendo poolId (eventos):', e);
                return null;
            }
        }

        // --- Agregador: dame el poolId como sea
        async function getPoolIdFromTx(hash) {
            let id = await getPoolIdFromReturnValue(hash);
            if (!id) id = await getPoolIdFromEventsByTx(hash);

            // último recurso: si tu contrato guarda NextPoolId, puedes leerlo y restar 1
            // id = id ?? await getLastPoolIdByCounter(); // (opcional)
            return id;
        }

        // Variable global para controlar resync
        let didResyncOnce = false;

        // Función helper para renderizar lista de pools (usada en fallbacks)
        function renderPoolsList(pools) {
          const grid = document.getElementById('pools-grid');
          if (!grid) return;
          grid.innerHTML = '';
          for (const pool of pools) {
            renderPoolCard(Number(pool.id), pool, pool.status);
            rememberActivePool(pool);
            scheduleDeadlineWatcher(pool.id, pool.deadline);
          }
          refreshContribDropdownFromCache();
        }


        async function loadActivePools() {
            try {
                // Permitir ver pools sin wallet, solo bloquear "crear/aportar" si no hay wallet
                // Primera carga: normal, SIN resync (el backend ya hidrata al boot)
                const qs = '?filter=actionable'; // producción
                didResyncOnce = true;
                let res;
                try {
                    res = await fetch('/api/pools' + qs, { method: 'GET' });
                } catch (e) {
                    // si hubo reset, espera un poco y reintenta
                    await new Promise(r => setTimeout(r, 1500));
                    res = await fetch('/api/pools?filter=actionable', { method: 'GET' });
                }
                
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const { pools } = await res.json();

                // Fallback 1: si viene vacío, intenta ver TODO (sin filtro)
                if (pools.length === 0) {
                    try {
                        const r2 = await fetch('/api/pools?all=1&_retried=1');
                        if (r2.ok) {
                            const j2 = await r2.json();
                            if (j2.pools?.length) {
                                renderPoolsList(j2.pools);
                                return;
                            }
                        }
                    } catch {}
                }

                // Guardar snapshot en localStorage
                try { localStorage.setItem('pools_snapshot', JSON.stringify(pools)); } catch(_) {}

                // Limpia UI previa
                const container = document.getElementById('pools-list');
                if (container) container.innerHTML = '';

                // Dibuja todas y actualiza caches/dropdown
                for (const pool of pools) {
                    const status = pool.status; // viene del backend
                    const poolId = Number(pool.id);
                    renderPoolCard(poolId, pool, status);          // ya la tienes
                    rememberActivePool(pool);                      // ya la tienes
                    scheduleDeadlineWatcher(poolId, pool.deadline);// ya la tienes
                    // 👇 Nueva sincronización on-chain cuando hay wallet conectada
                    if (isConnected && userAddress) {
                        try { await getPoolInfo(poolId); } catch (_) {}
                    }
                }
                refreshContribDropdownFromCache();               // ya la tienes

                showAlert(`✅ ${pools.length} cooperativa(s) cargadas`, 'success');
            } catch (e) {
                // Log removed
                showAlert('❌ No se pudieron cargar las cooperativas públicas', 'danger');
            }
        }

        // Verificar estado de transacción por hash
        async function checkTransactionStatus() {
            const hash = prompt('Ingresa el hash de la transacción:');
            if (!hash) return;

            try {
                // Log removed
                // Log removed

                const response = await server.getTransaction(hash);
                // Log removed

                if (response.status === 'SUCCESS') {
                    showAlert(`✅ Transacción exitosa!\nHash: ${hash}\nLedger: ${response.ledger}`, 'success');
                } else if (response.status === 'PENDING') {
                    showAlert(`⏳ Transacción pendiente\nHash: ${hash}\nÚltimo ledger: ${response.latestLedger}`, 'info');
                } else if (response.status === 'ERROR') {
                    showAlert(`❌ Transacción falló\nHash: ${hash}\nError: ${JSON.stringify(response.errorResult)}`, 'danger');
                } else {
                    showAlert(`ℹ️ Estado: ${response.status}\nHash: ${hash}`, 'info');
                }

            } catch (error) {
                // Log removed
                showAlert('❌ Error verificando transacción: ' + error.message, 'danger');
            }
        }

        // Verificar estado de la última transacción (si está almacenada)
        let lastTransactionHash = null;

        // Guarda el hash para la UI y para reintentos tras refresh
        function storeLastTransaction(hash) {
            lastTransactionHash = hash;
            localStorage.setItem('lastTxHash', hash);
            // Log removed
        }

        // Cargar hash desde localStorage al inicializar
        function loadLastTransaction() {
            const stored = localStorage.getItem('lastTxHash');
            if (stored) {
                lastTransactionHash = stored;
                // Hash cargado desde localStorage
            }
        }

        // Funciones mínimas para el panel de proceso (necesarias para createPool)
        function showProcessPanel() {
            // Función vacía - el panel ya no existe pero las llamadas no fallan
        }

        function setProcessStep(stepNumber, status = 'active') {
            // Función vacía - el panel ya no existe pero las llamadas no fallan
        }

        function updateProcessStatus(text, isActive = true) {
            // Función vacía - el panel ya no existe pero las llamadas no fallan
        }

        function hideProcessPanel() {
            // Función vacía - el panel ya no existe pero las llamadas no fallan
        }

        function showProcessHash(hash) {
            // Función vacía - el panel ya no existe pero las llamadas no fallan
        }

        function hideProcessHash() {
            // Función vacía - el panel ya no existe pero las llamadas no fallan
        }

        // --- Helper: conversión XLM/stroops ---
        function stroopsToXlm(stroops) {
            return Number(stroops) / 1e7;
        }
        
        function xlmToStroops(xlm) {
            return BigInt(Math.floor(Number(xlm) * 1e7));
        }

        /** Lee on-chain y fija el "máximo" del input según lo que falta de la pool */
        async function setContribMaxFor(poolId) {
            const res = await getPoolInfo(poolId);         // ya tienes esta función; devuelve { pool, status }
            if (!res || !res.pool) return;

            const pool = res.pool;
            const remaining = BigInt(pool.goal) - BigInt(pool.raised);
            const input = document.getElementById('contrib-amount');
            const btn   = document.getElementById('contrib-btn');

            if (!input || !btn) return;

            if (remaining <= 0n || pool.finalized) {
                input.max = '0';
                input.placeholder = 'Meta alcanzada';
                input.value = '';
                btn.disabled = true;
                showAlert('Esta cooperativa ya alcanzó su meta o no le queda cupo.', 'warning');
                return;
            }

            const maxXlm = stroopsToXlm(remaining);
            input.max = String(maxXlm);
            input.placeholder = `máx ${maxXlm} XLM`;
            input.dataset.maxStroops = remaining.toString(); // lo reutilizaremos en el submit
            btn.disabled = false;
            
            // Cinturón y tirantes: asegurar que la selección se mantiene
            const sel = document.getElementById('contrib-pool-select');
            if (sel) sel.value = String(poolId);
        }

        /** Si el usuario teclea más del máximo, lo recortamos y avisamos */
        function enforceContribInputMax() {
            const input = document.getElementById('contrib-amount');
            if (!input) return;
            const max = parseFloat(input.max || '0');
            const val = parseFloat(input.value || '0');
            if (max > 0 && val > max) {
                input.value = String(max);
                showAlert(`Se ajustó automáticamente al máximo permitido (${max} XLM).`, 'info');
            }
            updateConversion('contrib-amount', 'contrib-conversion');
        }

        // --- Helper: llamada cruda al RPC (asegura usar "hash")
        async function rawGetTransactionStatus(rpcUrl, hash) {
            const h = String(hash).trim();
            if (h.length !== 64) throw new Error(`hash inválido (${h.length} chars)`);
            const body = { jsonrpc: "2.0", id: 1, method: "getTransaction", params: { hash: h } };
            const r = await fetch(rpcUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
            const j = await r.json();
            if (j?.error) throw new Error(j.error.message || "RPC error");
            return {
                status: j?.result?.status ?? "NOT_FOUND",
                ledger: j?.result?.ledger,
                latestLedger: j?.result?.latestLedger,
                latestLedgerCloseTime: j?.result?.latestLedgerCloseTime,
                returnValue: j?.result?.returnValue // algunos RPC lo incluyen
            };
        }

        // --- Helper: intenta SDK y si falla usa RPC crudo
        async function safeGetTransaction(hash) {
            try { 
                return await server.getTransaction(hash); 
            } catch (e) { 
                // Log removed
                return await rawGetTransactionStatus(CONFIG.sorobanRpcUrl, hash);
            }
        }

        // --- Helper: normaliza un ScVal venga como venga
        function toScVal(scvLike) {
            if (!scvLike) return null;
            try {
                if (scvLike instanceof StellarSdk.xdr.ScVal) return scvLike;
                if (typeof scvLike === 'string') return StellarSdk.xdr.ScVal.fromXDR(scvLike, 'base64');
                if (typeof scvLike === 'object' && typeof scvLike.xdr === 'string')
                    return StellarSdk.xdr.ScVal.fromXDR(scvLike.xdr, 'base64');
            } catch (e) {
                // Log removed
            }
            return null;
        }

        // Poll de estado de transacción (Soroban RPC) - Versión robusta con fallback
        async function waitForTx(hash, { intervalMs = 2500, maxMs = 180000 } = {}) {
            const start = Date.now();
            // Log removed
            
            while (true) {
                try {
                    let res;
                    try {
                        // 1) Intento normal con el SDK
                        res = await server.getTransaction(hash);
                    } catch (sdkErr) {
                        console.warn('⚠️ getTransaction (SDK) falló, usando RPC crudo:', sdkErr?.message || sdkErr);
                        // 2) Fallback "crudo" sin decodificar XDR
                        res = await rawGetTransactionStatus(CONFIG.sorobanRpcUrl, hash);
                    }

                    // Log removed

                    // NOT_FOUND | PENDING | SUCCESS | FAILED
                    if (res.status === 'SUCCESS' || res.status === 'FAILED') {
                        // Log removed
                        return res;
                    }

                    if (Date.now() - start > maxMs) {
                        throw new Error('Timeout esperando confirmación');
                    }
                    await new Promise(r => setTimeout(r, intervalMs));
                } catch (error) {
                    // Log removed
                    if (Date.now() - start > maxMs) throw error;
                    await new Promise(r => setTimeout(r, intervalMs));
                }
            }
        }

        async function checkLastTransaction() {
            if (!lastTransactionHash) {
                showAlert('❌ No hay transacción reciente para verificar', 'danger');
                return;
            }

            try {
                // Log removed
                // Log removed

                const response = await safeGetTransaction(lastTransactionHash);

                // Log removed

                if (response.status === 'SUCCESS') {
                    showAlert(`✅ ¡Transacción exitosa!\nHash: ${lastTransactionHash}\nLedger: ${response.ledger}`, 'success');
                } else if (response.status === 'PENDING') {
                    showAlert(`⏳ Transacción pendiente\nHash: ${lastTransactionHash}\nÚltimo ledger: ${response.latestLedger}`, 'info');
                } else if (response.status === 'ERROR') {
                    showAlert(`❌ Transacción falló\nHash: ${lastTransactionHash}\nError: ${JSON.stringify(response.errorResult)}`, 'danger');
                } else {
                    showAlert(`ℹ️ Estado: ${response.status}\nHash: ${lastTransactionHash}`, 'info');
                }

            } catch (error) {
                // Log removed
                showAlert('❌ Error verificando transacción: ' + error.message, 'danger');
            }
        }

        // Inicializar cuando se carga la página
        window.addEventListener('load', init);
        
        // Inicializar conversiones cuando se carga la página
        document.addEventListener('DOMContentLoaded', function() {
            updateConversion('goal', 'goal-conversion');
            updateConversion('contrib-amount', 'contrib-conversion');
            
            // Configurar campo de fecha con valor por defecto (+30 días)
            const deadlineEl = document.getElementById('deadline');
            if (deadlineEl) {
                const now = new Date();
                deadlineEl.min = formatLocalDatetime(now);
                
                const defaultDate = new Date();
                defaultDate.setDate(defaultDate.getDate() + 30);
                deadlineEl.value = formatLocalDatetime(defaultDate);
            }
            
            // Inicializar carrusel de plantillas
            generateCarouselCards();
            
            // Limitar por pool seleccionada
            const selPool = document.getElementById('contrib-pool-select');
            if (selPool) {
                selPool.addEventListener('change', e => {
                    const id = Number(e.target.value);
                    if (Number.isFinite(id) && id > 0) setContribMaxFor(id);
                });
            }

            // Limitar mientras escribe
            const amt = document.getElementById('contrib-amount');
            if (amt) {
                amt.addEventListener('input', enforceContribInputMax);
            }
        });
    </script>
</body>
</html>
                                
